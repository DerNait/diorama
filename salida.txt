accel.rs:
// accel.rs
use raylib::prelude::Vector3;
use crate::ray_intersect::{Intersect, RayIntersect};

#[derive(Clone, Copy)]
struct Aabb { min: Vector3, max: Vector3 }

impl Aabb {
    fn union(a: Aabb, b: Aabb) -> Aabb {
        Aabb {
            min: Vector3::new(a.min.x.min(b.min.x), a.min.y.min(b.min.y), a.min.z.min(b.min.z)),
            max: Vector3::new(a.max.x.max(b.max.x), a.max.y.max(b.max.y), a.max.z.max(b.max.z)),
        }
    }
    fn intersect_ray(&self, ro: Vector3, rd: Vector3) -> Option<(f32, f32)> {
        let inv = Vector3::new(1.0/rd.x, 1.0/rd.y, 1.0/rd.z);

        let mut t1 = (self.min.x - ro.x)*inv.x;
        let mut t2 = (self.max.x - ro.x)*inv.x;
        if t1>t2 { std::mem::swap(&mut t1, &mut t2); }

        let mut ty1 = (self.min.y - ro.y)*inv.y;
        let mut ty2 = (self.max.y - ro.y)*inv.y;
        if ty1>ty2 { std::mem::swap(&mut ty1, &mut ty2); }

        if t1>ty2 || ty1>t2 { return None; }
        if ty1>t1 { t1=ty1; }
        if ty2<t2 { t2=ty2; }

        let mut tz1 = (self.min.z - ro.z)*inv.z;
        let mut tz2 = (self.max.z - ro.z)*inv.z;
        if tz1>tz2 { std::mem::swap(&mut tz1, &mut tz2); }

        if t1>tz2 || tz1>t2 { return None; }
        if tz1>t1 { t1=tz1; }
        if tz2<t2 { t2=tz2; }

        Some((t1, t2))
    }
}

pub struct UniformGridAccel {
    bounds: Aabb,
    dims: [i32; 3],
    cell_size: Vector3,
    cells: Vec<Vec<usize>>, // por celda, índices a objects[]
}

impl UniformGridAccel {
    pub fn build(objects: &[Box<dyn RayIntersect>], desired_cell_size: f32) -> Self {
        // 1) Bounds globales
        let mut bounds = Aabb {
            min: Vector3::new(f32::INFINITY, f32::INFINITY, f32::INFINITY),
            max: Vector3::new(-f32::INFINITY, -f32::INFINITY, -f32::INFINITY),
        };
        let mut aabbs: Vec<Aabb> = Vec::with_capacity(objects.len());
        for obj in objects.iter() {
            let (mn, mx) = obj.aabb();
            let a = Aabb { min: mn, max: mx };
            aabbs.push(a);
            bounds = Aabb::union(bounds, a);
        }
        let pad = 1e-4;
        bounds.min = bounds.min - Vector3::new(pad, pad, pad);
        bounds.max = bounds.max + Vector3::new(pad, pad, pad);

        // 2) Dims
        let ext = bounds.max - bounds.min;
        let mut nx = (ext.x / desired_cell_size).ceil() as i32;
        let mut ny = (ext.y / desired_cell_size).ceil() as i32;
        let mut nz = (ext.z / desired_cell_size).ceil() as i32;
        nx = nx.max(1); ny = ny.max(1); nz = nz.max(1);

        let dims = [nx, ny, nz];
        let cell_size = Vector3::new(ext.x / nx as f32, ext.y / ny as f32, ext.z / nz as f32);
        let total = (nx as usize) * (ny as usize) * (nz as usize);
        let mut cells: Vec<Vec<usize>> = (0..total).map(|_| Vec::new()).collect();

        // 3) Insertar cada objeto en las celdas que toca
        for (i, a) in aabbs.iter().enumerate() {
            let min_ix = ((a.min.x - bounds.min.x) / cell_size.x).floor() as i32;
            let min_iy = ((a.min.y - bounds.min.y) / cell_size.y).floor() as i32;
            let min_iz = ((a.min.z - bounds.min.z) / cell_size.z).floor() as i32;
            let max_ix = ((a.max.x - bounds.min.x) / cell_size.x).floor() as i32;
            let max_iy = ((a.max.y - bounds.min.y) / cell_size.y).floor() as i32;
            let max_iz = ((a.max.z - bounds.min.z) / cell_size.z).floor() as i32;

            for iz in min_iz.max(0)..=max_iz.min(nz - 1) {
                for iy in min_iy.max(0)..=max_iy.min(ny - 1) {
                    for ix in min_ix.max(0)..=max_ix.min(nx - 1) {
                        let idx = ((iz * ny + iy) * nx + ix) as usize;
                        cells[idx].push(i);
                    }
                }
            }
        }

        UniformGridAccel { bounds, dims, cell_size, cells }
    }

    #[inline] fn cell_index(&self, ix: i32, iy: i32, iz: i32) -> usize {
        ((iz * self.dims[1] + iy) * self.dims[0] + ix) as usize
    }

    /// DDA estilo Amanatides & Woo: tMax son **tiempos absolutos**, tDelta es el incremento por celda.
    pub fn trace(&self, ro: &Vector3, rd: &Vector3, objects: &[Box<dyn RayIntersect>]) -> Intersect {
        let (mut t_enter, t_exit) = match self.bounds.intersect_ray(*ro, *rd) {
            Some(t) => t, None => return Intersect::empty(),
        };
        if t_exit < 0.0 { return Intersect::empty(); }
        if t_enter < 0.0 { t_enter = 0.0; }

        let eps = 1e-4;
        let pos = *ro + *rd * t_enter;

        // celda inicial
        let mut ix = ((pos.x - self.bounds.min.x) / self.cell_size.x).floor() as i32;
        let mut iy = ((pos.y - self.bounds.min.y) / self.cell_size.y).floor() as i32;
        let mut iz = ((pos.z - self.bounds.min.z) / self.cell_size.z).floor() as i32;
        ix = ix.clamp(0, self.dims[0]-1);
        iy = iy.clamp(0, self.dims[1]-1);
        iz = iz.clamp(0, self.dims[2]-1);

        // pasos y tiempos a la siguiente pared (absolutos)
        let step_x = if rd.x > 0.0 { 1 } else if rd.x < 0.0 { -1 } else { 0 };
        let step_y = if rd.y > 0.0 { 1 } else if rd.y < 0.0 { -1 } else { 0 };
        let step_z = if rd.z > 0.0 { 1 } else if rd.z < 0.0 { -1 } else { 0 };

        let next_x = self.bounds.min.x + (ix + (step_x > 0) as i32) as f32 * self.cell_size.x;
        let next_y = self.bounds.min.y + (iy + (step_y > 0) as i32) as f32 * self.cell_size.y;
        let next_z = self.bounds.min.z + (iz + (step_z > 0) as i32) as f32 * self.cell_size.z;

        let mut t_max_x = if step_x != 0 { t_enter + (next_x - pos.x) / rd.x } else { f32::INFINITY };
        let mut t_max_y = if step_y != 0 { t_enter + (next_y - pos.y) / rd.y } else { f32::INFINITY };
        let mut t_max_z = if step_z != 0 { t_enter + (next_z - pos.z) / rd.z } else { f32::INFINITY };

        let t_delta_x = if step_x != 0 { self.cell_size.x / rd.x.abs() } else { f32::INFINITY };
        let t_delta_y = if step_y != 0 { self.cell_size.y / rd.y.abs() } else { f32::INFINITY };
        let t_delta_z = if step_z != 0 { self.cell_size.z / rd.z.abs() } else { f32::INFINITY };

        let mut best = Intersect::empty();
        let mut best_t = f32::INFINITY;

        loop {
            // probar objetos en la celda
            let cell_idx = self.cell_index(ix, iy, iz);
            for &obj_idx in &self.cells[cell_idx] {
                let i = objects[obj_idx].ray_intersect(ro, rd);
                if i.is_intersecting && i.distance >= t_enter - eps && i.distance < best_t {
                    best_t = i.distance;
                    best = i;
                }
            }

            // Si el hit ocurre antes de salir de la celda actual, listo
            let t_cell_exit = t_max_x.min(t_max_y).min(t_max_z);
            if best_t <= t_cell_exit { break; }

            // Avanzar a la siguiente celda en el eje con menor tMax
            if t_max_x < t_max_y {
                if t_max_x < t_max_z {
                    ix += step_x; if ix < 0 || ix >= self.dims[0] { break; }
                    t_enter = t_max_x; t_max_x += t_delta_x;
                } else {
                    iz += step_z; if iz < 0 || iz >= self.dims[2] { break; }
                    t_enter = t_max_z; t_max_z += t_delta_z;
                }
            } else {
                if t_max_y < t_max_z {
                    iy += step_y; if iy < 0 || iy >= self.dims[1] { break; }
                    t_enter = t_max_y; t_max_y += t_delta_y;
                } else {
                    iz += step_z; if iz < 0 || iz >= self.dims[2] { break; }
                    t_enter = t_max_z; t_max_z += t_delta_z;
                }
            }
            if t_enter > t_exit { break; }
        }

        best
    }

    /// Sombra: true si hay intersección antes de `max_t`
    pub fn occluded(&self, ro: &Vector3, rd: &Vector3, max_t: f32, objects: &[Box<dyn RayIntersect>]) -> bool {
        let (mut t_enter, t_exit) = match self.bounds.intersect_ray(*ro, *rd) {
            Some(t) => t, None => return false,
        };
        if t_exit < 0.0 { return false; }
        if t_enter < 0.0 { t_enter = 0.0; }
        let eps = 1e-4;
        let pos = *ro + *rd * t_enter;

        let mut ix = ((pos.x - self.bounds.min.x) / self.cell_size.x).floor() as i32;
        let mut iy = ((pos.y - self.bounds.min.y) / self.cell_size.y).floor() as i32;
        let mut iz = ((pos.z - self.bounds.min.z) / self.cell_size.z).floor() as i32;
        ix = ix.clamp(0, self.dims[0]-1);
        iy = iy.clamp(0, self.dims[1]-1);
        iz = iz.clamp(0, self.dims[2]-1);

        let step_x = if rd.x > 0.0 { 1 } else if rd.x < 0.0 { -1 } else { 0 };
        let step_y = if rd.y > 0.0 { 1 } else if rd.y < 0.0 { -1 } else { 0 };
        let step_z = if rd.z > 0.0 { 1 } else if rd.z < 0.0 { -1 } else { 0 };

        let next_x = self.bounds.min.x + (ix + (step_x > 0) as i32) as f32 * self.cell_size.x;
        let next_y = self.bounds.min.y + (iy + (step_y > 0) as i32) as f32 * self.cell_size.y;
        let next_z = self.bounds.min.z + (iz + (step_z > 0) as i32) as f32 * self.cell_size.z;

        let mut t_max_x = if step_x != 0 { t_enter + (next_x - pos.x) / rd.x } else { f32::INFINITY };
        let mut t_max_y = if step_y != 0 { t_enter + (next_y - pos.y) / rd.y } else { f32::INFINITY };
        let mut t_max_z = if step_z != 0 { t_enter + (next_z - pos.z) / rd.z } else { f32::INFINITY };

        let t_delta_x = if step_x != 0 { self.cell_size.x / rd.x.abs() } else { f32::INFINITY };
        let t_delta_y = if step_y != 0 { self.cell_size.y / rd.y.abs() } else { f32::INFINITY };
        let t_delta_z = if step_z != 0 { self.cell_size.z / rd.z.abs() } else { f32::INFINITY };

        loop {
            let cell_idx = self.cell_index(ix, iy, iz);
            for &obj_idx in &self.cells[cell_idx] {
                let i = objects[obj_idx].ray_intersect(ro, rd);
                if i.is_intersecting && i.distance > eps && i.distance < max_t {
                    return true;
                }
            }

            let t_cell_exit = t_max_x.min(t_max_y).min(t_max_z);
            if t_cell_exit >= max_t { break; }

            if t_max_x < t_max_y {
                if t_max_x < t_max_z {
                    ix += step_x; if ix < 0 || ix >= self.dims[0] { break; }
                    t_enter = t_max_x; t_max_x += t_delta_x;
                } else {
                    iz += step_z; if iz < 0 || iz >= self.dims[2] { break; }
                    t_enter = t_max_z; t_max_z += t_delta_z;
                }
            } else {
                if t_max_y < t_max_z {
                    iy += step_y; if iy < 0 || iy >= self.dims[1] { break; }
                    t_enter = t_max_y; t_max_y += t_delta_y;
                } else {
                    iz += step_z; if iz < 0 || iz >= self.dims[2] { break; }
                    t_enter = t_max_z; t_max_z += t_delta_z;
                }
            }
            if t_enter > t_exit { break; }
        }
        false
    }
}

camera.rs:
use raylib::prelude::*;

/// A 3D camera that maintains its position and orientation in world space
pub struct Camera {
    pub eye: Vector3,     // Camera position in world coordinates
    pub center: Vector3,  // Point the camera is looking at
    pub up: Vector3,      // Up direction (initially world up, gets orthonormalized)
    pub forward: Vector3, // Direction camera is facing (computed from eye->center)
    pub right: Vector3,   // Right direction (perpendicular to forward and up)
}

impl Camera {
    /// Creates a new camera and computes its initial orientation
    pub fn new(eye: Vector3, center: Vector3, up: Vector3) -> Self {
        // Initialize camera with given parameters and zero vectors for computed values
        let mut camera = Camera {
            eye,
            center,
            up,
            forward: Vector3::zero(), // Will be computed
            right: Vector3::zero(),   // Will be computed
        };
        // Compute the orthonormal basis vectors (forward, right, up)
        camera.update_basis_vectors();
        camera
    }

    /// Recomputes the camera's orthonormal basis vectors from eye, center, and up
    pub fn update_basis_vectors(&mut self) {
        // Step 1: Calculate forward direction (from eye toward center)
        // This gives us the primary viewing direction
        self.forward = (self.center - self.eye).normalized();
        
        // Step 2: Calculate right direction using cross product
        // forward × up gives us a vector perpendicular to both (pointing right)
        // This assumes up is roughly correct but may not be perfectly orthogonal
        self.right = self.forward.cross(self.up).normalized();
        
        // Step 3: Recalculate up to ensure perfect orthogonality
        // right × forward gives us a vector perpendicular to both
        // This creates a true orthonormal basis (all vectors perpendicular, unit length)
        self.up = self.right.cross(self.forward);
        
        // Note: We now have an orthonormal coordinate system:
        // - forward: direction camera looks
        // - right: rightward direction from camera's perspective  
        // - up: upward direction from camera's perspective
    }

    /// Rotates the camera around the center point (orbital camera movement)
    pub fn orbit(&mut self, yaw: f32, pitch: f32) {
        // Step 1: Get camera position relative to the center point
        // This treats center as origin for rotation calculations
        let relative_pos = self.eye - self.center;
        
        // Step 2: Convert to spherical coordinates for easier rotation
        // Calculate current distance from center (radius in spherical coordinates)
        let radius = relative_pos.length();
        
        // Calculate current angles
        // Current yaw: angle around Y axis (horizontal rotation)
        let current_yaw = relative_pos.z.atan2(relative_pos.x);
        // Current pitch: angle from horizontal plane (vertical rotation)
        let current_pitch = (relative_pos.y / radius).asin();
        
        // Step 3: Apply rotation deltas
        let new_yaw = current_yaw + yaw;
        let new_pitch = (current_pitch + pitch).clamp(-1.5, 1.5); // Clamp to avoid gimbal lock
        
        // Step 4: Convert back to Cartesian coordinates using trigonometry
        // Spherical to Cartesian: x = r*cos(pitch)*cos(yaw), y = r*sin(pitch), z = r*cos(pitch)*sin(yaw)
        let cos_pitch = new_pitch.cos();
        let new_relative_pos = Vector3::new(
            radius * cos_pitch * new_yaw.cos(),  // X component
            radius * new_pitch.sin(),            // Y component  
            radius * cos_pitch * new_yaw.sin(),  // Z component
        );
        
        // Step 5: Convert back to world coordinates by adding center back
        self.eye = self.center + new_relative_pos;
        
        // Step 6: Recompute basis vectors for new camera orientation
        self.update_basis_vectors();
    }

    /// Transforms a vector from camera space to world space using basis vectors
    pub fn basis_change(&self, v: &Vector3) -> Vector3 {
        // This performs a change of basis transformation
        // Input: vector in camera coordinate system
        // Output: same vector expressed in world coordinate system
        
        // In camera space coordinates:
        // - X axis points right
        // - Y axis points up  
        // - Z axis points backward (away from what camera sees)
        //   Note: This follows right-handed convention where camera looks down -Z
        
        // The math: to convert from camera space to world space,
        // we need to express the camera space vector as a linear combination
        // of world space basis vectors
        
        // World X component = v.x * right.x + v.y * up.x - v.z * forward.x
        // (negative v.z because camera Z points backward, but forward points forward)
        Vector3::new(
            v.x * self.right.x + v.y * self.up.x - v.z * self.forward.x,
            v.x * self.right.y + v.y * self.up.y - v.z * self.forward.y,
            v.x * self.right.z + v.y * self.up.z - v.z * self.forward.z,
        )
        
        // Example: if v = (1,0,0) in camera space (pointing right),
        // result will be self.right in world space
        // if v = (0,0,1) in camera space (pointing backward),
        // result will be -self.forward in world space
    }
}

color_ops.rs:
use raylib::prelude::Color;

pub trait ColorOps {
    fn mult_f32(&self, factor: f32) -> Color;
}

impl ColorOps for Color {
    fn mult_f32(&self, factor: f32) -> Color {
        Color::new(
            (self.r as f32 * factor).min(255.0) as u8,
            (self.g as f32 * factor).min(255.0) as u8,
            (self.b as f32 * factor).min(255.0) as u8,
            self.a,
        )
    }
}

cube.rs:
use std::sync::Arc;
use raylib::prelude::Vector3;

use crate::material::Material;
use crate::ray_intersect::{Intersect, RayIntersect};
use crate::texture::Texture;

#[derive(Clone, Copy)]
pub enum Face { PosX, NegX, PosY, NegY, PosZ, NegZ }
impl Face {
    #[inline] fn idx(self) -> usize {
        match self { Face::PosX=>0, Face::NegX=>1, Face::PosY=>2, Face::NegY=>3, Face::PosZ=>4, Face::NegZ=>5 }
    }
}

/// AABB con texturas por cara (opcionales, compartidas por Arc)
pub struct Cube {
    pub min: Vector3,
    pub max: Vector3,
    pub material: Material,
    face_textures: [Option<Arc<Texture>>; 6],
}

impl Cube {
    pub fn from_center_size(center: Vector3, size: Vector3, material: Material) -> Self {
        let half = size * 0.5;
        Cube {
            min: center - half,
            max: center + half,
            material,
            face_textures: [None, None, None, None, None, None],
        }
    }

    pub fn new(min: Vector3, max: Vector3, material: Material) -> Self {
        Cube { min, max, material, face_textures: [None, None, None, None, None, None] }
    }

    pub fn set_face_texture(&mut self, face: Face, tex: Arc<Texture>) {
        self.face_textures[face.idx()] = Some(tex);
    }

    pub fn set_face_textures_from_template(&mut self, tpl: &[Option<Arc<Texture>>; 6]) {
        self.face_textures = [
            tpl[0].clone(), tpl[1].clone(), tpl[2].clone(),
            tpl[3].clone(), tpl[4].clone(), tpl[5].clone(),
        ];
    }
}

impl RayIntersect for Cube {
    fn ray_intersect(&self, ro: &Vector3, rd: &Vector3) -> Intersect {
        // Slabs con tracking del eje de entrada (robusto en aristas)
        let inv = Vector3::new(1.0 / rd.x, 1.0 / rd.y, 1.0 / rd.z);

        let (tx1, tx2) = ((self.min.x - ro.x) * inv.x, (self.max.x - ro.x) * inv.x);
        let (ty1, ty2) = ((self.min.y - ro.y) * inv.y, (self.max.y - ro.y) * inv.y);
        let (tz1, tz2) = ((self.min.z - ro.z) * inv.z, (self.max.z - ro.z) * inv.z);

        let tmin_x = tx1.min(tx2);
        let tmax_x = tx1.max(tx2);
        let tmin_y = ty1.min(ty2);
        let tmax_y = ty1.max(ty2);
        let tmin_z = tz1.min(tz2);
        let tmax_z = tz1.max(tz2);

        let t_enter = tmin_x.max(tmin_y).max(tmin_z);
        let t_exit  = tmax_x.min(tmax_y).min(tmax_z);

        if t_exit < 0.0 || t_enter > t_exit {
            return Intersect::empty();
        }

        let t_hit = if t_enter > 0.0 { t_enter } else { t_exit };
        if !t_hit.is_finite() { return Intersect::empty(); }

        let p = *ro + *rd * t_hit;

        // Eje de la cara golpeada = aquel que “define” t_enter (el mayor de tmin_*)
        // En empates (arista), la prioridad X>Y>Z es estable y evita parpadeo.
        let face = if t_enter == tmin_x || (tmin_x > tmin_y && tmin_x > tmin_z) {
            if rd.x > 0.0 { Face::NegX } else { Face::PosX }
        } else if t_enter == tmin_y || (tmin_y > tmin_z) {
            if rd.y > 0.0 { Face::NegY } else { Face::PosY }
        } else {
            if rd.z > 0.0 { Face::NegZ } else { Face::PosZ }
        };

        let normal = match face {
            Face::PosX => Vector3::new( 1.0, 0.0, 0.0),
            Face::NegX => Vector3::new(-1.0, 0.0, 0.0),
            Face::PosY => Vector3::new( 0.0, 1.0, 0.0),
            Face::NegY => Vector3::new( 0.0,-1.0, 0.0),
            Face::PosZ => Vector3::new( 0.0, 0.0, 1.0),
            Face::NegZ => Vector3::new( 0.0, 0.0,-1.0),
        };

        // UV por cara (misma convención que traías)
        let size = self.max - self.min;
        let (mut u, mut v) = match face {
            // laterales X: u = a lo largo de Z, v hacia -Y (imagen top->v=0)
            Face::PosX => ( (p.z - self.min.z) / size.z, (self.max.y - p.y) / size.y ),
            Face::NegX => ( (self.max.z - p.z) / size.z, (self.max.y - p.y) / size.y ),
            // tapa/base
            Face::PosY => ( (p.x - self.min.x) / size.x, (p.z - self.min.z) / size.z ),
            Face::NegY => ( (p.x - self.min.x) / size.x, (self.max.z - p.z) / size.z ),
            // frente/fondo
            Face::PosZ => ( (p.x - self.min.x) / size.x, (self.max.y - p.y) / size.y ),
            Face::NegZ => ( (self.max.x - p.x) / size.x, (self.max.y - p.y) / size.y ),
        };

        // Clampeamos sutilmente para evitar costuras (u/v=0 ó 1 exactos)
        let tiny = 1e-6f32;
        u = u.clamp(0.0 + tiny, 1.0 - tiny);
        v = v.clamp(0.0 + tiny, 1.0 - tiny);

        // Material final (textura si hay; muestreo CLAMP para seamless)
        let final_material = if let Some(tex) = &self.face_textures[face.idx()] {
            let tex_color = tex.sample_clamp(u, v);
            Material { diffuse: tex_color, ..self.material }
        } else {
            self.material
        };

        Intersect::new(p, normal, t_hit, final_material)
    }

    fn aabb(&self) -> (Vector3, Vector3) {
        (self.min, self.max)
    }
}

framebuffer.rs:
// framebuffer.rs

use raylib::prelude::*;

pub struct Framebuffer {
    pub width: u32,
    pub height: u32,
    pub color_buffer: Image,
    background_color: Color,
    current_color: Color,
}

impl Framebuffer {
    pub fn new(width: u32, height: u32) -> Self {
        let color_buffer = Image::gen_image_color(width as i32, height as i32, Color::BLACK);
        Framebuffer {
            width,
            height,
            color_buffer,
            background_color: Color::BLACK,
            current_color: Color::WHITE,
        }
    }

    pub fn clear(&mut self) {
        self.color_buffer = Image::gen_image_color(self.width as i32, self.height as i32, self.background_color);
    }

    pub fn set_pixel(&mut self, x: u32, y: u32) {
        if x < self.width && y < self.height {
            self.color_buffer.draw_pixel(x as i32, y as i32, self.current_color);
        }
    }

    pub fn set_background_color(&mut self, color: Color) {
        self.background_color = color;
    }

    pub fn set_current_color(&mut self, color: Color) {
        self.current_color = color;
    }

    pub fn _render_to_file(&self, file_path: &str) {
        self.color_buffer.export_image(file_path);
    }

    pub fn swap_buffers(
        &self,
        window: &mut RaylibHandle,
        raylib_thread: &RaylibThread,
    ) {
        if let Ok(texture) = window.load_texture_from_image(raylib_thread, &self.color_buffer) {
            let mut renderer = window.begin_drawing(raylib_thread);
            renderer.draw_texture(&texture, 0, 0, Color::WHITE);
        }
    }
}

light.rs:
use raylib::prelude::*;

/// Tipo de luz
#[derive(Clone, Copy, Debug)]
pub enum LightKind {
    Point,        // usa position
    Directional,  // usa direction (vector unitario, sentido = hacia donde viaja la luz)
}

pub struct Light {
    pub kind: LightKind,
    pub position: Vector3,  // usado si kind = Point
    pub direction: Vector3, // usado si kind = Directional (unitario)
    pub color: Color,
    pub intensity: f32,
}

impl Light {
    /// Luz puntual (compat con tu código anterior)
    pub fn new(position: Vector3, color: Color, intensity: f32) -> Self {
        Self {
            kind: LightKind::Point,
            position,
            direction: Vector3::new(-1.0, -1.0, -1.0).normalized(),
            color,
            intensity,
        }
    }

    /// Luz direccional (tipo Sol). `dir` es hacia dónde viaja la luz.
    pub fn directional(dir: Vector3, color: Color, intensity: f32) -> Self {
        let d = if dir.length() > 0.0 { dir.normalized() } else { Vector3::new(-1.0,-1.0,-1.0).normalized() };
        Self {
            kind: LightKind::Directional,
            position: Vector3::zero(),
            direction: d,
            color,
            intensity,
        }
    }

    /// Devuelve (light_dir, light_distance) desde un punto de la escena:
    /// - light_dir: vector unitario desde el punto hacia la fuente de luz
    /// - light_distance: distancia hasta la luz (∞ si es direccional)
    pub fn at(&self, point: Vector3) -> (Vector3, f32) {
        match self.kind {
            LightKind::Point => {
                let to = self.position - point;
                let dist = to.length();
                if dist > 0.0 { (to / dist, dist) } else { (Vector3::new(0.0, -1.0, 0.0), 0.0) }
            }
            LightKind::Directional => {
                // direction = hacia dónde viaja la luz, así que desde el punto hacia la fuente es -direction
                (-self.direction, f32::INFINITY)
            }
        }
    }

    /// Mueve la luz puntual
    pub fn translate(&mut self, delta: Vector3) {
        if matches!(self.kind, LightKind::Point) {
            self.position += delta;
        }
    }

    /// Rotación yaw/pitch para luz direccional (en ejes globales Y/X)
    pub fn yaw_pitch(&mut self, yaw: f32, pitch: f32) {
        if !matches!(self.kind, LightKind::Directional) { return; }
        // ángulos actuales a partir del vector direction
        let mut dir = self.direction;
        let r = dir.length();
        if r == 0.0 { dir = Vector3::new(-1.0,-1.0,-1.0).normalized(); }

        let mut cur_yaw   = dir.z.atan2(dir.x);          // [-pi, pi]
        let mut cur_pitch = (dir.y).asin().clamp(-0.999, 0.999); // [-~pi/2, ~pi/2]

        cur_yaw += yaw;
        cur_pitch = (cur_pitch + pitch).clamp(-1.3, 1.3);

        let cp = cur_pitch.cos();
        let x = cp * cur_yaw.cos();
        let y = cur_pitch.sin();
        let z = cp * cur_yaw.sin();

        self.direction = Vector3::new(x, y, z).normalized();
    }
}

main.rs:
use raylib::prelude::*;
use std::f32::consts::PI;
use std::sync::Arc;

mod framebuffer;
mod ray_intersect;
mod sphere;
mod camera;
mod light;
mod material;
mod cube;
mod texture;
mod scene;
mod palette;
mod accel;

use framebuffer::Framebuffer;
use ray_intersect::{Intersect, RayIntersect};
use camera::Camera;
use light::{Light, LightKind};
use material::{Material, vector3_to_color};
use palette::{Palette, CubeTemplate};
use accel::UniformGridAccel;

use crate::texture::Texture;

const ORIGIN_BIAS: f32 = 1e-3;

#[inline]
fn lerp(a: Vector3, b: Vector3, t: f32) -> Vector3 { a * (1.0 - t) + b * t }

#[inline]
fn smooth5(t: f32) -> f32 {
    // smoothstep quintico (suave y sin bandas)
    let t = t.clamp(0.0, 1.0);
    t * t * t * (t * (t * 6.0 - 15.0) + 10.0)
}

fn procedural_sky(dir: Vector3) -> Vector3 {
    let d = dir.normalized();
    // t=0 cerca del horizonte, t=1 en el cénit
    let t = ((d.y) * 0.5 + 0.5).clamp(0.0, 1.0);

    // Paleta "Nocturne Violet" (morado-negro)
    let horizon = Vector3::new(0.08, 0.04, 0.12); // más claro en horizonte
    let mid     = Vector3::new(0.03, 0.015, 0.06);
    let top     = Vector3::new(0.015, 0.010, 0.030); // casi negro con tinte violeta

    // Gradiente en dos tramos con curvas suaves
    let c = if t < 0.6 {
        let k = smooth5(t / 0.6);            // horizonte -> medio
        lerp(horizon, mid, k)
    } else {
        let k = smooth5((t - 0.6) / 0.4);    // medio -> cénit
        lerp(mid, top, k)
    };

    // Leve brillo/magia de horizonte (muy sutil y oscuro, no “blanco”)
    let h = (1.0 - t).clamp(0.0, 1.0);           // 1 cerca del horizonte
    let glow = h.powf(5.0);                      // curva agresiva para que solo afecte abajo
    let glow_col = Vector3::new(0.20, 0.05, 0.15); // magenta oscuro
    let c = c + glow_col * (0.08 * glow);        // intensidad pequeña

    // Pequeña “niebla” atmosférica violeta en bajo ángulo (evita sky totalmente plano)
    let haze = (1.0 - t).powf(2.0) * 0.03;
    let c = c + Vector3::new(haze * 0.6, haze * 0.3, haze);

    // clamp final a [0,1]
    Vector3::new(c.x.clamp(0.0, 1.0), c.y.clamp(0.0, 1.0), c.z.clamp(0.0, 1.0))
}


fn offset_origin(intersect: &Intersect, direction: &Vector3) -> Vector3 {
    let offset = intersect.normal * ORIGIN_BIAS;
    if direction.dot(intersect.normal) < 0.0 { intersect.point - offset } else { intersect.point + offset }
}

fn reflect(incident: &Vector3, normal: &Vector3) -> Vector3 {
    *incident - *normal * 2.0 * incident.dot(*normal)
}

fn refract(incident: &Vector3, normal: &Vector3, refractive_index: f32) -> Option<Vector3> {
    let mut cosi = incident.dot(*normal).max(-1.0).min(1.0);
    let mut etai = 1.0;
    let mut etat = refractive_index;
    let mut n = *normal;

    if cosi > 0.0 {
        std::mem::swap(&mut etai, &mut etat);
        n = -n;
    } else {
        cosi = -cosi;
    }

    let eta = etai / etat;
    let k = 1.0 - eta * eta * (1.0 - cosi * cosi);
    if k < 0.0 { None } else { Some(*incident * eta + n * (eta * cosi - k.sqrt())) }
}

fn cast_shadow(
    intersect: &Intersect,
    light: &Light,
    objects: &[Box<dyn RayIntersect>],
    accel: &UniformGridAccel,
) -> f32 {
    let (light_dir, light_distance) = light.at(intersect.point);
    let shadow_ray_origin = offset_origin(intersect, &light_dir);
    if accel.occluded(&shadow_ray_origin, &light_dir, light_distance, objects) { 1.0 } else { 0.0 }
}

pub fn cast_ray(
    ray_origin: &Vector3,
    ray_direction: &Vector3,
    objects: &[Box<dyn RayIntersect>],
    accel: &UniformGridAccel,
    light: &Light,
    depth: u32,
) -> Vector3 {
    if depth > 3 { return procedural_sky(*ray_direction); }

    let mut intersect = accel.trace(ray_origin, ray_direction, objects);

    if !intersect.is_intersecting {
        return procedural_sky(*ray_direction);
    }

    let (light_dir, _light_distance) = light.at(intersect.point);
    let view_dir  = (*ray_origin - intersect.point).normalized();
    let reflect_dir = reflect(&-light_dir, &intersect.normal).normalized();

    let shadow_intensity = cast_shadow(&intersect, light, objects, accel);
    let light_intensity = light.intensity * (1.0 - shadow_intensity);

    // Half-Lambert (k=0.3) + ambient 0.15
    let diffuse_intensity = ((intersect.normal.dot(light_dir) + 0.3) / 1.3).clamp(0.0, 1.0) * light_intensity;
    let diffuse = intersect.material.diffuse * diffuse_intensity;

    let specular_intensity = view_dir.dot(reflect_dir).max(0.0).powf(intersect.material.specular) * light_intensity;
    let light_color_v3 = Vector3::new(
        light.color.r as f32 / 255.0,
        light.color.g as f32 / 255.0,
        light.color.b as f32 / 255.0
    );
    let specular = light_color_v3 * specular_intensity;

    let albedo = intersect.material.albedo;
    let phong_color = (diffuse + intersect.material.diffuse * 0.15) * albedo[0] + specular * albedo[1];

    // Reflections
    let reflectivity = intersect.material.albedo[2];
    let reflect_color = if reflectivity > 0.0 {
        let reflect_dir = reflect(ray_direction, &intersect.normal).normalized();
        let reflect_origin = offset_origin(&intersect, &reflect_dir);
        cast_ray(&reflect_origin, &reflect_dir, objects, accel, light, depth + 1)
    } else { Vector3::zero() };

    // Refractions
    let transparency = intersect.material.albedo[3];
    let refract_color = if transparency > 0.0 {
        if let Some(refract_dir) = refract(ray_direction, &intersect.normal, intersect.material.refractive_index) {
            let refract_origin = offset_origin(&intersect, &refract_dir);
            cast_ray(&refract_origin, &refract_dir, objects, accel, light, depth + 1)
        } else {
            let reflect_dir = reflect(ray_direction, &intersect.normal).normalized();
            let reflect_origin = offset_origin(&intersect, &reflect_dir);
            cast_ray(&reflect_origin, &reflect_dir, objects, accel, light, depth + 1)
        }
    } else { Vector3::zero() };

    phong_color * (1.0 - reflectivity - transparency) + reflect_color * reflectivity + refract_color * transparency
}

pub fn render(framebuffer: &mut Framebuffer, objects: &[Box<dyn RayIntersect>], accel: &UniformGridAccel, camera: &Camera, light: &Light) {
    let width = framebuffer.width as f32;
    let height = framebuffer.height as f32;
    let aspect_ratio = width / height;
    let fov = PI / 3.0;
    let perspective_scale = (fov * 0.5).tan();

    for y in 0..framebuffer.height {
        for x in 0..framebuffer.width {
            let screen_x = (2.0 * x as f32) / width - 1.0;
            let screen_y = -(2.0 * y as f32) / height + 1.0;

            let screen_x = screen_x * aspect_ratio * perspective_scale;
            let screen_y = screen_y * perspective_scale;

            let ray_direction = Vector3::new(screen_x, screen_y, -1.0).normalized();
            let rotated_direction = camera.basis_change(&ray_direction);

            let pixel_color_v3 = cast_ray(&camera.eye, &rotated_direction, objects, accel, light, 0);
            let pixel_color = vector3_to_color(pixel_color_v3);

            framebuffer.set_current_color(pixel_color);
            framebuffer.set_pixel(x, y);
        }
    }
}

fn main() {
    let window_width = 1300;
    let window_height = 900;
 
    let (mut window, thread) = raylib::init()
        .size(window_width, window_height)
        .title("Raytracer Example")
        .log_level(TraceLogLevel::LOG_WARNING)
        .build();

    let mut framebuffer = Framebuffer::new(window_width as u32, window_height as u32);

    // ======= PALETA =======
    let stone = Material::new(
        Vector3::new(0.55, 0.55, 0.55),
        25.0,
        [0.85, 0.15, 0.0, 0.0],
        0.0,
    );
    let grass_mat = Material::new(
        Vector3::new(1.0, 1.0, 1.0),
        20.0,
        [0.9, 0.1, 0.0, 0.0],
        0.0,
    );
    let crate_mat = Material::new(
        Vector3::new(1.0, 1.0, 1.0),
        30.0,
        [0.8, 0.2, 0.0, 0.0],
        0.0,
    );

    use std::sync::Arc;
    let grass_top   = Arc::new(Texture::from_file("assets/cube/posy.png"));
    let grass_side  = Arc::new(Texture::from_file("assets/cube/posx.png"));
    let dirt        = Arc::new(Texture::from_file("assets/cube/negy.png"));
    let crate_tex   = Arc::new(Texture::from_file("assets/cube/negy.png"));

    let mut palette = Palette::new();
    palette.set('G', CubeTemplate::material_only(stone));
    palette.set('X', CubeTemplate::with_top_bottom_sides(grass_mat, grass_top, dirt, grass_side));
    palette.set('C', CubeTemplate::with_same_texture(crate_mat, crate_tex));

    // ===== CARGA ESCENA ASCII SIN GAPS =====
    let cube_size = Vector3::new(1.0, 1.0, 1.0);
    let mut params = scene::default_params(cube_size);
    params.gap = Vector3::new(0.0, 0.0, 0.0);
    params.origin = Vector3::new(0.0, 0.0, 0.0);
    params.y0 = -0.5;
    params.y_step = 1.0;

    let default_mat = stone;

    let objects: Vec<Box<dyn RayIntersect>> =
        scene::load_ascii_layers_with_palette("assets/scene", &params, &palette, default_mat)
            .expect("Error leyendo assets/scene");

    // ===== Aceleración por grilla =====
    let accel = UniformGridAccel::build(&objects, cube_size.x.max(0.01));

    // Cámara
    let mut camera = Camera::new(
        Vector3::new(0.0, 1.5, 5.0),
        Vector3::new(0.0, 0.0, 0.0),
        Vector3::new(0.0, 1.0, 0.0),
    );
    let rotation_speed = PI / 100.0;

    // ===== Luz (mut) =====
    // Cambia a Point si prefieres:
    // let mut light = Light::new(Vector3::new(1.0, -1.0, 5.0), Color::WHITE, 1.5);
    let mut light = Light::directional(Vector3::new(-1.0, -1.0, 0.3), Color::new(255,255,255,255), 1.2);

    // Controles
    let dir_rot_speed = PI / 300.0;
    let move_speed = 0.15;

    while !window.window_should_close() {
        // Cámara orbit
        if window.is_key_down(KeyboardKey::KEY_LEFT)  { camera.orbit(rotation_speed, 0.0); }
        if window.is_key_down(KeyboardKey::KEY_RIGHT) { camera.orbit(-rotation_speed, 0.0); }
        if window.is_key_down(KeyboardKey::KEY_UP)    { camera.orbit(0.0, -rotation_speed); }
        if window.is_key_down(KeyboardKey::KEY_DOWN)  { camera.orbit(0.0,  rotation_speed); }

        // Toggle tipo de luz
        if window.is_key_pressed(KeyboardKey::KEY_ONE) { light.kind = LightKind::Point; }
        if window.is_key_pressed(KeyboardKey::KEY_TWO) { light.kind = LightKind::Directional; }

        // Rotar dirección (direccional): J/L (yaw), I/K (pitch)
        if matches!(light.kind, LightKind::Directional) {
            if window.is_key_down(KeyboardKey::KEY_J) { light.yaw_pitch( dir_rot_speed, 0.0); }
            if window.is_key_down(KeyboardKey::KEY_L) { light.yaw_pitch(-dir_rot_speed, 0.0); }
            if window.is_key_down(KeyboardKey::KEY_I) { light.yaw_pitch(0.0,  dir_rot_speed); }
            if window.is_key_down(KeyboardKey::KEY_K) { light.yaw_pitch(0.0, -dir_rot_speed); }
        }

        // Mover posición (puntual): WASD + R/F
        if matches!(light.kind, LightKind::Point) {
            if window.is_key_down(KeyboardKey::KEY_W) { light.translate(Vector3::new( 0.0, 0.0, -move_speed)); }
            if window.is_key_down(KeyboardKey::KEY_S) { light.translate(Vector3::new( 0.0, 0.0,  move_speed)); }
            if window.is_key_down(KeyboardKey::KEY_A) { light.translate(Vector3::new(-move_speed, 0.0, 0.0)); }
            if window.is_key_down(KeyboardKey::KEY_D) { light.translate(Vector3::new( move_speed, 0.0, 0.0)); }
            if window.is_key_down(KeyboardKey::KEY_R) { light.translate(Vector3::new( 0.0,  move_speed, 0.0)); }
            if window.is_key_down(KeyboardKey::KEY_F) { light.translate(Vector3::new( 0.0, -move_speed, 0.0)); }
        }

        framebuffer.clear();
        render(&mut framebuffer, &objects, &accel, &camera, &light);
        framebuffer.swap_buffers(&mut window, &thread);
    }
}

material.rs:
use raylib::prelude::{Color, Vector3};

#[derive(Debug, Clone, Copy)]
pub struct Material {
    pub diffuse: Vector3,
    pub albedo: [f32; 4],
    pub specular: f32,
    pub refractive_index: f32,
}

impl Material {
    pub fn new(diffuse: Vector3, specular: f32, albedo: [f32; 4], refractive_index: f32) -> Self {
        Material {
            diffuse,
            albedo,
            specular,
            refractive_index,
        }
    }

    pub fn black() -> Self {
        Material {
            diffuse: Vector3::zero(),
            albedo: [0.0, 0.0, 0.0, 0.0],
            specular: 0.0,
            refractive_index: 0.0,
        }
    }
}

pub fn vector3_to_color(v: Vector3) -> Color {
    Color::new(
        (v.x * 255.0).min(255.0) as u8,
        (v.y * 255.0).min(255.0) as u8,
        (v.z * 255.0).min(255.0) as u8,
        255,
    )
}

palette.rs:
// palette.rs
use std::collections::HashMap;
use std::sync::Arc;

use crate::material::Material;
use crate::texture::Texture;

/// Orden de caras (importante):
/// [PosX, NegX, PosY, NegY, PosZ, NegZ]
///  - PosY = tapa (arriba), NegY = base.
///  - PosZ = frente, NegZ = fondo.
#[derive(Clone)]
pub struct CubeTemplate {
    pub material: Material,
    pub face_textures: [Option<Arc<Texture>>; 6],
}

impl CubeTemplate {
    /// Solo material (sin texturas)
    pub fn material_only(material: Material) -> Self {
        CubeTemplate {
            material,
            face_textures: [None, None, None, None, None, None],
        }
    }

    /// Misma textura en las 6 caras
    pub fn with_same_texture(material: Material, tex: Arc<Texture>) -> Self {
        CubeTemplate {
            face_textures: [
                Some(tex.clone()), Some(tex.clone()), Some(tex.clone()),
                Some(tex.clone()), Some(tex.clone()), Some(tex),
            ],
            material,
        }
    }

    /// Top / Bottom / Sides (lados iguales), útil para terreno tipo Minecraft
    pub fn with_top_bottom_sides(
        material: Material,
        top: Arc<Texture>,
        bottom: Arc<Texture>,
        side: Arc<Texture>,
    ) -> Self {
        CubeTemplate {
            face_textures: [
                Some(side.clone()),  // PosX
                Some(side.clone()),  // NegX
                Some(top.clone()),   // PosY (tapa)
                Some(bottom.clone()),// NegY (base)
                Some(side.clone()),  // PosZ
                Some(side),          // NegZ
            ],
            material,
        }
    }

    /// 6 caras explícitas (usa `None` para “sin textura” en una cara)
    pub fn with_faces(
        material: Material,
        faces: [Option<Arc<Texture>>; 6],
    ) -> Self {
        CubeTemplate { material, face_textures: faces }
    }
}

pub struct Palette {
    map: HashMap<char, CubeTemplate>,
}

impl Palette {
    pub fn new() -> Self {
        Palette { map: HashMap::new() }
    }
    pub fn set(&mut self, ch: char, tpl: CubeTemplate) {
        self.map.insert(ch, tpl);
    }
    pub fn get(&self, ch: char) -> Option<&CubeTemplate> {
        self.map.get(&ch)
    }
}

ray_intersect.rs:
use raylib::prelude::Vector3;
use crate::material::Material;

#[derive(Debug, Clone, Copy)]
#[allow(dead_code)]
pub struct Intersect {
    pub point: Vector3,
    pub normal: Vector3,
    pub distance: f32,
    pub is_intersecting: bool,
    pub material: Material,
}

impl Intersect {
    pub fn new(point: Vector3, normal: Vector3, distance: f32, material: Material) -> Self {
        Intersect {
            point,
            normal,
            distance,
            is_intersecting: true,
            material,
        }
    }

    pub fn empty() -> Self {
        Intersect {
            point: Vector3::zero(),
            normal: Vector3::zero(),
            distance: 0.0,
            is_intersecting: false,
            material: Material::black(),
        }
    }
}

pub trait RayIntersect {
    fn ray_intersect(&self, ray_origin: &Vector3, ray_direction: &Vector3) -> Intersect;

    /// AABB en espacio mundo para aceleración (grilla/BVH).
    fn aabb(&self) -> (Vector3, Vector3);
}


scene.rs:
// scene.rs
use std::{fs, io};

use raylib::prelude::Vector3;

use crate::cube::Cube;
use crate::material::Material;
use crate::palette::{CubeTemplate, Palette};
use crate::ray_intersect::RayIntersect;

/// Parámetros para construir la escena a partir de ASCII layers.
pub struct SceneParams {
    pub cube_size: Vector3,
    pub gap: Vector3,
    pub origin: Vector3,
    pub y0: f32,
    pub y_step: f32,
    pub any_non_whitespace_is_solid: bool,
    pub solid_chars: Vec<char>,
}

pub fn load_ascii_layers_with_palette(
    dir: &str,
    params: &SceneParams,
    palette: &Palette,
    default_material: Material,
) -> io::Result<Vec<Box<dyn RayIntersect>>> {
    let mut entries: Vec<_> = fs::read_dir(dir)?
        .filter_map(|e| e.ok())
        .filter(|e| {
            let p = e.path();
            p.is_file() && p.extension().map(|ext| ext == "txt").unwrap_or(false)
        })
        .collect();

    entries.sort_by_key(|e| e.path());

    let mut objects: Vec<Box<dyn RayIntersect>> = Vec::new();

    for (layer_idx, entry) in entries.into_iter().enumerate() {
        let path = entry.path();
        let text = fs::read_to_string(&path)?;

        let mut lines: Vec<String> = text
            .lines()
            .map(|s| s.trim_end_matches(&['\r', '\n'][..]).to_string())
            .collect();

        while matches!(lines.first(), Some(s) if s.trim().is_empty()) { lines.remove(0); }
        while matches!(lines.last(), Some(s) if s.trim().is_empty()) { lines.pop(); }
        if lines.is_empty() { continue; }

        let rows = lines.len();
        let cols = lines.iter().map(|s| s.chars().count()).max().unwrap_or(0);

        // pasos entre centros: SIN GAPS si gap = 0
        let step_x = params.cube_size.x + params.gap.x;
        let step_z = params.cube_size.z + params.gap.z;

        let half_w = (cols as f32 - 1.0) * 0.5;
        let half_h = (rows as f32 - 1.0) * 0.5;

        let y_center = params.y0 + layer_idx as f32 * params.y_step;

        for (r, line) in lines.iter().enumerate() {
            let mut chars = line.chars().collect::<Vec<char>>();
            if chars.len() < cols { chars.resize(cols, ' '); }

            for c in 0..cols {
                let ch = chars[c];

                // sólido si está en paleta o según flags
                let has_tpl = palette.get(ch).is_some();
                let solid = if params.any_non_whitespace_is_solid {
                    !ch.is_whitespace()
                } else {
                    params.solid_chars.contains(&ch) || has_tpl
                };
                if !solid { continue; }

                let x = (c as f32 - half_w) * step_x;
                let z = (r as f32 - half_h) * step_z;
                let center = params.origin + Vector3::new(x, y_center, z);

                let mut cube = Cube::from_center_size(center, params.cube_size, default_material);

                // aplica plantilla si existe
                if let Some(tpl) = palette.get(ch) {
                    cube.material = tpl.material;
                    cube.set_face_textures_from_template(&tpl.face_textures);
                }
                objects.push(Box::new(cube));
            }
        }
    }

    Ok(objects)
}

pub fn default_params(cube_size: Vector3) -> SceneParams {
    SceneParams {
        cube_size,
        gap: Vector3::new(0.0, 0.0, 0.0), // << sin espacios
        origin: Vector3::zero(),
        y0: -cube_size.y * 0.5,
        y_step: cube_size.y,
        any_non_whitespace_is_solid: false, // << usaremos paleta por carácter
        solid_chars: vec!['X'],             // << arranca con 'X'
    }
}

sphere.rs:
use crate::material::Material;
use crate::ray_intersect::{Intersect, RayIntersect};
use raylib::prelude::Vector3;

pub struct Sphere {
    pub center: Vector3,
    pub radius: f32,
    pub material: Material,
}

impl RayIntersect for Sphere {
    fn ray_intersect(&self, ray_origin: &Vector3, ray_direction: &Vector3) -> Intersect {
        let oc = *ray_origin - self.center;

        let a = ray_direction.dot(*ray_direction);
        let b = 2.0 * oc.dot(*ray_direction);
        let c = oc.dot(oc) - self.radius * self.radius;

        let discriminant = b * b - 4.0 * a * c;

        if discriminant > 0.0 {
            let t = (-b - discriminant.sqrt()) / (2.0 * a);
            if t > 0.0 {
                let point = *ray_origin + *ray_direction * t;
                let normal = (point - self.center).normalized();
                let distance = t;

                return Intersect::new(point, normal, distance, self.material);
            }
        }

        Intersect::empty()
    }

    fn aabb(&self) -> (Vector3, Vector3) {
        let r = Vector3::new(self.radius, self.radius, self.radius);
        (self.center - r, self.center + r)
    }
}

texture.rs:
use raylib::prelude::*;

/// Textura CPU-side con muestreo por UV.
/// Guarda el buffer de colores para muestrear sin pedir &mut.
pub struct Texture {
    width: i32,
    height: i32,
    pixels: ImageColors, // Box<[Color]> administrado por raylib-rs
}

impl Texture {
    pub fn from_file(path: &str) -> Self {
        let img = Image::load_image(path).expect("No se pudo cargar la textura");
        let w = img.width();
        let h = img.height();
        let pixels = img.get_image_data(); // row-major, origen top-left
        Texture { width: w, height: h, pixels }
    }

    /// ---- MODO REPEAT (wrap) ----
    /// Devuelve color lineal [0,1] por UV, con wrap repetido.
    /// Convención: v=0 es fila superior (top), v=1 inferior (bottom).
    #[inline]
    pub fn sample_repeat(&self, mut u: f32, mut v: f32) -> Vector3 {
        // Wrap a [0,1)
        u = u.fract();
        if u < 0.0 { u += 1.0; }
        v = v.fract();
        if v < 0.0 { v += 1.0; }

        // Centro de texel: (u*W - 0.5, v*H - 0.5)
        let sx = u * self.width as f32  - 0.5;
        let sy = v * self.height as f32 - 0.5;

        let xi = sx.floor().clamp(0.0, self.width  as f32 - 1.0)  as usize;
        let yi = sy.floor().clamp(0.0, self.height as f32 - 1.0)  as usize;
        let idx = yi * self.width as usize + xi;

        let c = self.pixels[idx];
        Vector3::new(c.r as f32 / 255.0, c.g as f32 / 255.0, c.b as f32 / 255.0)
    }

    /// ---- MODO CLAMP (sin wrap) ----
    /// Clampa los UV a los centros de texel válidos para evitar costuras en 0/1.
    #[inline]
    pub fn sample_clamp(&self, mut u: f32, mut v: f32) -> Vector3 {
        // “Inset” de medio texel en UV-space
        let eps_u = 0.5 / self.width as f32;
        let eps_v = 0.5 / self.height as f32;
        u = u.clamp(eps_u, 1.0 - eps_u);
        v = v.clamp(eps_v, 1.0 - eps_v);

        // Centro de texel
        let sx = u * self.width as f32  - 0.5;
        let sy = v * self.height as f32 - 0.5;

        let xi = sx.floor().clamp(0.0, self.width  as f32 - 1.0)  as usize;
        let yi = sy.floor().clamp(0.0, self.height as f32 - 1.0)  as usize;
        let idx = yi * self.width as usize + xi;

        let c = self.pixels[idx];
        Vector3::new(c.r as f32 / 255.0, c.g as f32 / 255.0, c.b as f32 / 255.0)
    }

    /// Alias para compatibilidad: por defecto, repeat.
    #[inline]
    pub fn sample(&self, u: f32, v: f32) -> Vector3 {
        self.sample_repeat(u, v)
    }
}

