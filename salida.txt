accel.rs:
// accel.rs
use raylib::prelude::Vector3;
use crate::ray_intersect::{Intersect, RayIntersect};

#[derive(Clone, Copy)]
struct Aabb { min: Vector3, max: Vector3 }

impl Aabb {
    fn union(a: Aabb, b: Aabb) -> Aabb {
        Aabb {
            min: Vector3::new(a.min.x.min(b.min.x), a.min.y.min(b.min.y), a.min.z.min(b.min.z)),
            max: Vector3::new(a.max.x.max(b.max.x), a.max.y.max(b.max.y), a.max.z.max(b.max.z)),
        }
    }
    fn intersect_ray(&self, ro: Vector3, rd: Vector3) -> Option<(f32, f32)> {
        let inv = Vector3::new(1.0/rd.x, 1.0/rd.y, 1.0/rd.z);

        let mut t1 = (self.min.x - ro.x)*inv.x;
        let mut t2 = (self.max.x - ro.x)*inv.x;
        if t1>t2 { std::mem::swap(&mut t1, &mut t2); }

        let mut ty1 = (self.min.y - ro.y)*inv.y;
        let mut ty2 = (self.max.y - ro.y)*inv.y;
        if ty1>ty2 { std::mem::swap(&mut ty1, &mut ty2); }

        if t1>ty2 || ty1>t2 { return None; }
        if ty1>t1 { t1=ty1; }
        if ty2<t2 { t2=ty2; }

        let mut tz1 = (self.min.z - ro.z)*inv.z;
        let mut tz2 = (self.max.z - ro.z)*inv.z;
        if tz1>tz2 { std::mem::swap(&mut tz1, &mut tz2); }

        if t1>tz2 || tz1>t2 { return None; }
        if tz1>t1 { t1=tz1; }
        if tz2<t2 { t2=tz2; }

        Some((t1, t2))
    }
}

pub struct UniformGridAccel {
    bounds: Aabb,
    dims: [i32; 3],
    cell_size: Vector3,
    cells: Vec<Vec<usize>>, // por celda, índices a objects[]
}

impl UniformGridAccel {
    pub fn build(objects: &[Box<dyn RayIntersect>], desired_cell_size: f32) -> Self {
        // 1) Bounds globales
        let mut bounds = Aabb {
            min: Vector3::new(f32::INFINITY, f32::INFINITY, f32::INFINITY),
            max: Vector3::new(-f32::INFINITY, -f32::INFINITY, -f32::INFINITY),
        };
        let mut aabbs: Vec<Aabb> = Vec::with_capacity(objects.len());
        for obj in objects.iter() {
            let (mn, mx) = obj.aabb();
            let a = Aabb { min: mn, max: mx };
            aabbs.push(a);
            bounds = Aabb::union(bounds, a);
        }
        let pad = 1e-4;
        bounds.min = bounds.min - Vector3::new(pad, pad, pad);
        bounds.max = bounds.max + Vector3::new(pad, pad, pad);

        // 2) Dims
        let ext = bounds.max - bounds.min;
        let mut nx = (ext.x / desired_cell_size).ceil() as i32;
        let mut ny = (ext.y / desired_cell_size).ceil() as i32;
        let mut nz = (ext.z / desired_cell_size).ceil() as i32;
        nx = nx.max(1); ny = ny.max(1); nz = nz.max(1);

        let dims = [nx, ny, nz];
        let cell_size = Vector3::new(ext.x / nx as f32, ext.y / ny as f32, ext.z / nz as f32);
        let total = (nx as usize) * (ny as usize) * (nz as usize);
        let mut cells: Vec<Vec<usize>> = (0..total).map(|_| Vec::new()).collect();

        // 3) Insertar cada objeto en las celdas que toca
        for (i, a) in aabbs.iter().enumerate() {
            let min_ix = ((a.min.x - bounds.min.x) / cell_size.x).floor() as i32;
            let min_iy = ((a.min.y - bounds.min.y) / cell_size.y).floor() as i32;
            let min_iz = ((a.min.z - bounds.min.z) / cell_size.z).floor() as i32;
            let max_ix = ((a.max.x - bounds.min.x) / cell_size.x).floor() as i32;
            let max_iy = ((a.max.y - bounds.min.y) / cell_size.y).floor() as i32;
            let max_iz = ((a.max.z - bounds.min.z) / cell_size.z).floor() as i32;

            for iz in min_iz.max(0)..=max_iz.min(nz - 1) {
                for iy in min_iy.max(0)..=max_iy.min(ny - 1) {
                    for ix in min_ix.max(0)..=max_ix.min(nx - 1) {
                        let idx = ((iz * ny + iy) * nx + ix) as usize;
                        cells[idx].push(i);
                    }
                }
            }
        }

        UniformGridAccel { bounds, dims, cell_size, cells }
    }

    #[inline] fn cell_index(&self, ix: i32, iy: i32, iz: i32) -> usize {
        ((iz * self.dims[1] + iy) * self.dims[0] + ix) as usize
    }

    /// DDA estilo Amanatides & Woo: tMax son **tiempos absolutos**, tDelta es el incremento por celda.
    pub fn trace(&self, ro: &Vector3, rd: &Vector3, objects: &[Box<dyn RayIntersect>]) -> Intersect {
        let (mut t_enter, t_exit) = match self.bounds.intersect_ray(*ro, *rd) {
            Some(t) => t, None => return Intersect::empty(),
        };
        if t_exit < 0.0 { return Intersect::empty(); }
        if t_enter < 0.0 { t_enter = 0.0; }

        let eps = 1e-4;
        let pos = *ro + *rd * t_enter;

        // celda inicial
        let mut ix = ((pos.x - self.bounds.min.x) / self.cell_size.x).floor() as i32;
        let mut iy = ((pos.y - self.bounds.min.y) / self.cell_size.y).floor() as i32;
        let mut iz = ((pos.z - self.bounds.min.z) / self.cell_size.z).floor() as i32;
        ix = ix.clamp(0, self.dims[0]-1);
        iy = iy.clamp(0, self.dims[1]-1);
        iz = iz.clamp(0, self.dims[2]-1);

        // pasos y tiempos a la siguiente pared (absolutos)
        let step_x = if rd.x > 0.0 { 1 } else if rd.x < 0.0 { -1 } else { 0 };
        let step_y = if rd.y > 0.0 { 1 } else if rd.y < 0.0 { -1 } else { 0 };
        let step_z = if rd.z > 0.0 { 1 } else if rd.z < 0.0 { -1 } else { 0 };

        let next_x = self.bounds.min.x + (ix + (step_x > 0) as i32) as f32 * self.cell_size.x;
        let next_y = self.bounds.min.y + (iy + (step_y > 0) as i32) as f32 * self.cell_size.y;
        let next_z = self.bounds.min.z + (iz + (step_z > 0) as i32) as f32 * self.cell_size.z;

        let mut t_max_x = if step_x != 0 { t_enter + (next_x - pos.x) / rd.x } else { f32::INFINITY };
        let mut t_max_y = if step_y != 0 { t_enter + (next_y - pos.y) / rd.y } else { f32::INFINITY };
        let mut t_max_z = if step_z != 0 { t_enter + (next_z - pos.z) / rd.z } else { f32::INFINITY };

        let t_delta_x = if step_x != 0 { self.cell_size.x / rd.x.abs() } else { f32::INFINITY };
        let t_delta_y = if step_y != 0 { self.cell_size.y / rd.y.abs() } else { f32::INFINITY };
        let t_delta_z = if step_z != 0 { self.cell_size.z / rd.z.abs() } else { f32::INFINITY };

        let mut best = Intersect::empty();
        let mut best_t = f32::INFINITY;

        loop {
            // probar objetos en la celda
            let cell_idx = self.cell_index(ix, iy, iz);
            for &obj_idx in &self.cells[cell_idx] {
                let i = objects[obj_idx].ray_intersect(ro, rd);
                if i.is_intersecting && i.distance >= t_enter - eps && i.distance < best_t {
                    best_t = i.distance;
                    best = i;
                }
            }

            // Si el hit ocurre antes de salir de la celda actual, listo
            let t_cell_exit = t_max_x.min(t_max_y).min(t_max_z);
            if best_t <= t_cell_exit { break; }

            // Avanzar a la siguiente celda en el eje con menor tMax
            if t_max_x < t_max_y {
                if t_max_x < t_max_z {
                    ix += step_x; if ix < 0 || ix >= self.dims[0] { break; }
                    t_enter = t_max_x; t_max_x += t_delta_x;
                } else {
                    iz += step_z; if iz < 0 || iz >= self.dims[2] { break; }
                    t_enter = t_max_z; t_max_z += t_delta_z;
                }
            } else {
                if t_max_y < t_max_z {
                    iy += step_y; if iy < 0 || iy >= self.dims[1] { break; }
                    t_enter = t_max_y; t_max_y += t_delta_y;
                } else {
                    iz += step_z; if iz < 0 || iz >= self.dims[2] { break; }
                    t_enter = t_max_z; t_max_z += t_delta_z;
                }
            }
            if t_enter > t_exit { break; }
        }

        best
    }

    /// Sombra: true si hay intersección antes de `max_t`
    pub fn occluded(&self, ro: &Vector3, rd: &Vector3, max_t: f32, objects: &[Box<dyn RayIntersect>]) -> bool {
        let (mut t_enter, t_exit) = match self.bounds.intersect_ray(*ro, *rd) {
            Some(t) => t, None => return false,
        };
        if t_exit < 0.0 { return false; }
        if t_enter < 0.0 { t_enter = 0.0; }
        let eps = 1e-4;
        let pos = *ro + *rd * t_enter;

        let mut ix = ((pos.x - self.bounds.min.x) / self.cell_size.x).floor() as i32;
        let mut iy = ((pos.y - self.bounds.min.y) / self.cell_size.y).floor() as i32;
        let mut iz = ((pos.z - self.bounds.min.z) / self.cell_size.z).floor() as i32;
        ix = ix.clamp(0, self.dims[0]-1);
        iy = iy.clamp(0, self.dims[1]-1);
        iz = iz.clamp(0, self.dims[2]-1);

        let step_x = if rd.x > 0.0 { 1 } else if rd.x < 0.0 { -1 } else { 0 };
        let step_y = if rd.y > 0.0 { 1 } else if rd.y < 0.0 { -1 } else { 0 };
        let step_z = if rd.z > 0.0 { 1 } else if rd.z < 0.0 { -1 } else { 0 };

        let next_x = self.bounds.min.x + (ix + (step_x > 0) as i32) as f32 * self.cell_size.x;
        let next_y = self.bounds.min.y + (iy + (step_y > 0) as i32) as f32 * self.cell_size.y;
        let next_z = self.bounds.min.z + (iz + (step_z > 0) as i32) as f32 * self.cell_size.z;

        let mut t_max_x = if step_x != 0 { t_enter + (next_x - pos.x) / rd.x } else { f32::INFINITY };
        let mut t_max_y = if step_y != 0 { t_enter + (next_y - pos.y) / rd.y } else { f32::INFINITY };
        let mut t_max_z = if step_z != 0 { t_enter + (next_z - pos.z) / rd.z } else { f32::INFINITY };

        let t_delta_x = if step_x != 0 { self.cell_size.x / rd.x.abs() } else { f32::INFINITY };
        let t_delta_y = if step_y != 0 { self.cell_size.y / rd.y.abs() } else { f32::INFINITY };
        let t_delta_z = if step_z != 0 { self.cell_size.z / rd.z.abs() } else { f32::INFINITY };

        loop {
            let cell_idx = self.cell_index(ix, iy, iz);
            for &obj_idx in &self.cells[cell_idx] {
                let i = objects[obj_idx].ray_intersect(ro, rd);
                if i.is_intersecting && i.distance > eps && i.distance < max_t {
                    return true;
                }
            }

            let t_cell_exit = t_max_x.min(t_max_y).min(t_max_z);
            if t_cell_exit >= max_t { break; }

            if t_max_x < t_max_y {
                if t_max_x < t_max_z {
                    ix += step_x; if ix < 0 || ix >= self.dims[0] { break; }
                    t_enter = t_max_x; t_max_x += t_delta_x;
                } else {
                    iz += step_z; if iz < 0 || iz >= self.dims[2] { break; }
                    t_enter = t_max_z; t_max_z += t_delta_z;
                }
            } else {
                if t_max_y < t_max_z {
                    iy += step_y; if iy < 0 || iy >= self.dims[1] { break; }
                    t_enter = t_max_y; t_max_y += t_delta_y;
                } else {
                    iz += step_z; if iz < 0 || iz >= self.dims[2] { break; }
                    t_enter = t_max_z; t_max_z += t_delta_z;
                }
            }
            if t_enter > t_exit { break; }
        }
        false
    }
}

camera.rs:
use raylib::prelude::*;

/// Configuración de la cámara orbital (fácil de tunear).
#[derive(Clone, Copy, Debug)]
pub struct CameraConfig {
    /// Sensibilidad de órbita (radianes por unidad de input).
    pub orbit_sensitivity_yaw: f32,
    pub orbit_sensitivity_pitch: f32,
    /// Sensibilidad de zoom (unidades de distancia por input).
    pub zoom_sensitivity: f32,
    /// Límites del pitch (en radianes). Usualmente (-pi/2 + eps, pi/2 - eps).
    pub min_pitch: f32,
    pub max_pitch: f32,
    /// Límites de distancia (zoom). min>0.
    pub min_distance: f32,
    pub max_distance: f32,
}

impl Default for CameraConfig {
    fn default() -> Self {
        Self {
            orbit_sensitivity_yaw:   1.0,
            orbit_sensitivity_pitch: 1.0,
            zoom_sensitivity:        1.0,
            min_pitch:  -1.45,   // ~ -83°
            max_pitch:   1.45,   // ~  83°
            min_distance: 0.25,
            max_distance: 5000.0, // “zoom out” muy grande pero controlado
        }
    }
}

/// Base precomputada para “ray directions”.
#[derive(Clone, Copy)]
pub struct CameraBasis {
    pub eye: Vector3,
    pub forward: Vector3,
    pub right: Vector3,
    pub up: Vector3,
}

/// Cámara orbital: siempre mira al centro.
pub struct Camera {
    /// Punto que orbitamos y observamos.
    pub center: Vector3,
    /// Distancia desde la cámara al centro.
    pub distance: f32,
    /// Ángulos esféricos (en radianes).
    pub yaw: f32,   // rotación alrededor del eje Y (horizontal)
    pub pitch: f32, // elevación
    /// Vectores base (se actualizan con `update_basis_vectors`)
    pub eye: Vector3,
    pub forward: Vector3,
    pub right: Vector3,
    pub up: Vector3,
    /// Config editable
    pub config: CameraConfig,
}

impl Camera {
    /// Crea una cámara orbital a partir de (eye, center, up).
    /// Mantiene compatibilidad con tu código actual.
    pub fn new(eye: Vector3, center: Vector3, up_hint: Vector3) -> Self {
        // Convertimos a “coordenadas esféricas” respecto al centro.
        let offset = eye - center;
        let mut distance = offset.length().max(1e-6);
        let pitch = (offset.y / distance).asin();            // [-pi/2, pi/2]
        let yaw = offset.z.atan2(offset.x);                  // [-pi, pi]

        // Base inicial (usamos up_hint para orientar)
        let mut cam = Self {
            center,
            distance,
            yaw,
            pitch,
            eye: eye,
            forward: Vector3::zero(),
            right: Vector3::zero(),
            up: up_hint, // será corregido en update
            config: CameraConfig::default(),
        };

        cam.clamp_angles_and_distance();
        cam.update_eye_from_spherical();
        cam.update_basis_vectors();
        cam
    }

    /// Si prefieres crear con parámetros esféricos directos.
    pub fn from_spherical(center: Vector3, distance: f32, yaw: f32, pitch: f32) -> Self {
        let mut cam = Self {
            center,
            distance,
            yaw,
            pitch,
            eye: Vector3::zero(),
            forward: Vector3::zero(),
            right: Vector3::zero(),
            up: Vector3::new(0.0, 1.0, 0.0),
            config: CameraConfig::default(),
        };
        cam.clamp_angles_and_distance();
        cam.update_eye_from_spherical();
        cam.update_basis_vectors();
        cam
    }

    #[inline]
    pub fn set_config(&mut self, cfg: CameraConfig) {
        self.config = cfg;
        self.clamp_angles_and_distance();
        self.update_eye_from_spherical();
        self.update_basis_vectors();
    }

    /// Cambia el centro (target) manteniendo distancia/angulos.
    #[inline]
    pub fn set_center(&mut self, new_center: Vector3) {
        self.center = new_center;
        self.update_eye_from_spherical();
        self.update_basis_vectors();
    }

    /// Órbita sumando delta-yaw/pitch (en radianes) y clamp.
    pub fn orbit(&mut self, delta_yaw: f32, delta_pitch: f32) {
        self.yaw   += delta_yaw  * self.config.orbit_sensitivity_yaw;
        self.pitch += delta_pitch * self.config.orbit_sensitivity_pitch;
        // Normalizamos yaw a [-pi, pi] para evitar overflow numérico
        if self.yaw > std::f32::consts::PI { self.yaw -= 2.0*std::f32::consts::PI; }
        if self.yaw < -std::f32::consts::PI { self.yaw += 2.0*std::f32::consts::PI; }

        self.clamp_angles_and_distance();
        self.update_eye_from_spherical();
        self.update_basis_vectors();
    }

    /// Zoom dolly (acerca/aleja) manteniendo el centro.
    /// `amount` positivo aleja, negativo acerca (puedes invertir en input).
    pub fn zoom(&mut self, amount: f32) {
        self.distance += amount * self.config.zoom_sensitivity;
        self.clamp_angles_and_distance();
        self.update_eye_from_spherical();
        self.update_basis_vectors();
    }

    /// Variante de zoom “suave” (exponencial). Útil si quieres sentirlo más natural.
    pub fn zoom_exp(&mut self, amount: f32) {
        // amount > 0 aleja, < 0 acerca
        let factor = (1.0 + 0.2 * amount).max(0.05);
        self.distance *= factor;
        self.clamp_angles_and_distance();
        self.update_eye_from_spherical();
        self.update_basis_vectors();
    }

    /// Recalcula `eye` desde (center, distance, yaw, pitch).
    #[inline]
    fn update_eye_from_spherical(&mut self) {
        let cp = self.pitch.cos();
        let x = self.distance * cp * self.yaw.cos();
        let y = self.distance * self.pitch.sin();
        let z = self.distance * cp * self.yaw.sin();
        self.eye = self.center + Vector3::new(x, y, z);
    }

    /// Mantiene los límites de pitch/distancia seguros.
    #[inline]
    fn clamp_angles_and_distance(&mut self) {
        self.pitch = self.pitch.clamp(self.config.min_pitch, self.config.max_pitch);
        self.distance = self.distance.clamp(self.config.min_distance, self.config.max_distance);
    }

    /// Actualiza forward/right/up coherentes con la orientación actual.
    pub fn update_basis_vectors(&mut self) {
        self.forward = (self.center - self.eye).normalized();           // mira al centro
        // Usa Y global como “up” base para consistencia.
        let world_up = Vector3::new(0.0, 1.0, 0.0);
        // Si estamos demasiado cerca de singularidad, apóyate en forward.
        let mut right = self.forward.cross(world_up);
        if right.length() < 1e-6 {
            // forward casi paralelo a world_up: usa un up alterno
            let alt_up = Vector3::new(0.0, 0.0, 1.0);
            right = self.forward.cross(alt_up);
        }
        self.right = right.normalized();
        self.up = self.right.cross(self.forward).normalized();
    }

    /// Transformación de base cámara->mundo (igual a tu método anterior).
    #[inline]
    pub fn basis_change(&self, v: &Vector3) -> Vector3 {
        Vector3::new(
            v.x * self.right.x + v.y * self.up.x - v.z * self.forward.x,
            v.x * self.right.y + v.y * self.up.y - v.z * self.forward.y,
            v.x * self.right.z + v.y * self.up.z - v.z * self.forward.z,
        )
    }

    #[inline]
    pub fn basis(&self) -> CameraBasis {
        CameraBasis {
            eye: self.eye,
            forward: self.forward,
            right: self.right,
            up: self.up,
        }
    }
}

color_ops.rs:
use raylib::prelude::Color;

pub trait ColorOps {
    fn mult_f32(&self, factor: f32) -> Color;
}

impl ColorOps for Color {
    fn mult_f32(&self, factor: f32) -> Color {
        Color::new(
            (self.r as f32 * factor).min(255.0) as u8,
            (self.g as f32 * factor).min(255.0) as u8,
            (self.b as f32 * factor).min(255.0) as u8,
            self.a,
        )
    }
}

cube.rs:
use std::sync::Arc;
use raylib::prelude::Vector3;

use crate::material::Material;
use crate::ray_intersect::{Intersect, RayIntersect};
use crate::texture::Texture;

#[derive(Clone, Copy)]
pub enum Face { PosX, NegX, PosY, NegY, PosZ, NegZ }
impl Face {
    #[inline] fn idx(self) -> usize {
        match self { Face::PosX=>0, Face::NegX=>1, Face::PosY=>2, Face::NegY=>3, Face::PosZ=>4, Face::NegZ=>5 }
    }
}

/// AABB con texturas por cara (opcionales, compartidas por Arc)
pub struct Cube {
    pub min: Vector3,
    pub max: Vector3,
    pub material: Material,
    face_textures: [Option<Arc<Texture>>; 6],
}

impl Cube {
    pub fn from_center_size(center: Vector3, size: Vector3, material: Material) -> Self {
        let half = size * 0.5;
        Cube {
            min: center - half,
            max: center + half,
            material,
            face_textures: [None, None, None, None, None, None],
        }
    }

    pub fn new(min: Vector3, max: Vector3, material: Material) -> Self {
        Cube { min, max, material, face_textures: [None, None, None, None, None, None] }
    }

    pub fn set_face_texture(&mut self, face: Face, tex: Arc<Texture>) {
        self.face_textures[face.idx()] = Some(tex);
    }

    pub fn set_face_textures_from_template(&mut self, tpl: &[Option<Arc<Texture>>; 6]) {
        self.face_textures = [
            tpl[0].clone(), tpl[1].clone(), tpl[2].clone(),
            tpl[3].clone(), tpl[4].clone(), tpl[5].clone(),
        ];
    }
}

impl RayIntersect for Cube {
    fn ray_intersect(&self, ro: &Vector3, rd: &Vector3) -> Intersect {
        // Slabs con tracking del eje de entrada (robusto en aristas)
        let inv = Vector3::new(1.0 / rd.x, 1.0 / rd.y, 1.0 / rd.z);

        let (tx1, tx2) = ((self.min.x - ro.x) * inv.x, (self.max.x - ro.x) * inv.x);
        let (ty1, ty2) = ((self.min.y - ro.y) * inv.y, (self.max.y - ro.y) * inv.y);
        let (tz1, tz2) = ((self.min.z - ro.z) * inv.z, (self.max.z - ro.z) * inv.z);

        let tmin_x = tx1.min(tx2);
        let tmax_x = tx1.max(tx2);
        let tmin_y = ty1.min(ty2);
        let tmax_y = ty1.max(ty2);
        let tmin_z = tz1.min(tz2);
        let tmax_z = tz1.max(tz2);

        let t_enter = tmin_x.max(tmin_y).max(tmin_z);
        let t_exit  = tmax_x.min(tmax_y).min(tmax_z);

        if t_exit < 0.0 || t_enter > t_exit {
            return Intersect::empty();
        }

        let t_hit = if t_enter > 0.0 { t_enter } else { t_exit };
        if !t_hit.is_finite() { return Intersect::empty(); }

        let p = *ro + *rd * t_hit;

        // Eje de la cara golpeada = aquel que “define” t_enter (el mayor de tmin_*)
        // En empates (arista), la prioridad X>Y>Z es estable y evita parpadeo.
        let face = if t_enter == tmin_x || (tmin_x > tmin_y && tmin_x > tmin_z) {
            if rd.x > 0.0 { Face::NegX } else { Face::PosX }
        } else if t_enter == tmin_y || (tmin_y > tmin_z) {
            if rd.y > 0.0 { Face::NegY } else { Face::PosY }
        } else {
            if rd.z > 0.0 { Face::NegZ } else { Face::PosZ }
        };

        let normal = match face {
            Face::PosX => Vector3::new( 1.0, 0.0, 0.0),
            Face::NegX => Vector3::new(-1.0, 0.0, 0.0),
            Face::PosY => Vector3::new( 0.0, 1.0, 0.0),
            Face::NegY => Vector3::new( 0.0,-1.0, 0.0),
            Face::PosZ => Vector3::new( 0.0, 0.0, 1.0),
            Face::NegZ => Vector3::new( 0.0, 0.0,-1.0),
        };

        // UV por cara (misma convención que traías)
        let size = self.max - self.min;
        let (mut u, mut v) = match face {
            // laterales X: u = a lo largo de Z, v hacia -Y (imagen top->v=0)
            Face::PosX => ( (p.z - self.min.z) / size.z, (self.max.y - p.y) / size.y ),
            Face::NegX => ( (self.max.z - p.z) / size.z, (self.max.y - p.y) / size.y ),
            // tapa/base
            Face::PosY => ( (p.x - self.min.x) / size.x, (p.z - self.min.z) / size.z ),
            Face::NegY => ( (p.x - self.min.x) / size.x, (self.max.z - p.z) / size.z ),
            // frente/fondo
            Face::PosZ => ( (p.x - self.min.x) / size.x, (self.max.y - p.y) / size.y ),
            Face::NegZ => ( (self.max.x - p.x) / size.x, (self.max.y - p.y) / size.y ),
        };

        // Clampeamos sutilmente para evitar costuras (u/v=0 ó 1 exactos)
        let tiny = 1e-6f32;
        u = u.clamp(0.0 + tiny, 1.0 - tiny);
        v = v.clamp(0.0 + tiny, 1.0 - tiny);

        // Material final (textura si hay; muestreo CLAMP para seamless)
        let final_material = if let Some(tex) = &self.face_textures[face.idx()] {
            let tex_color = tex.sample_clamp(u, v);
            Material { diffuse: tex_color, ..self.material }
        } else {
            self.material
        };

        Intersect::new(p, normal, t_hit, final_material)
    }

    fn aabb(&self) -> (Vector3, Vector3) {
        (self.min, self.max)
    }
}

framebuffer.rs:
// framebuffer.rs

use raylib::prelude::*;

/// Framebuffer CPU con textura GPU persistente (sin recreación por frame).
pub struct Framebuffer {
    pub width: u32,
    pub height: u32,
    pixels: Vec<Color>,                               // buffer CPU: width*height
    texture_gpu: Option<raylib::texture::Texture2D>,  // textura persistente
    background_color: Color,
    current_color: Color,
}

impl Framebuffer {
    pub fn new(width: u32, height: u32) -> Self {
        let n = (width as usize) * (height as usize);
        Framebuffer {
            width,
            height,
            pixels: vec![Color::BLACK; n],
            texture_gpu: None,
            background_color: Color::BLACK,
            current_color: Color::WHITE,
        }
    }

    /// Debes crear la Texture2D UNA sola vez (desde un Image temporal) y adjuntarla aquí.
    pub fn attach_texture(&mut self, tex: raylib::texture::Texture2D) {
        self.texture_gpu = Some(tex);
    }

    /// Acceso mutable al buffer para render paralelo.
    #[inline]
    pub fn pixels_mut(&mut self) -> &mut [Color] {
        &mut self.pixels
    }

    /// Acceso de solo lectura, por si lo necesitas.
    #[inline]
    pub fn pixels(&self) -> &[Color] {
        &self.pixels
    }

    /// Limpia el buffer CPU sin recrearlo.
    pub fn clear(&mut self) {
        let bg = self.background_color;
        for px in self.pixels.iter_mut() {
            *px = bg;
        }
    }

    /// Escritura de píxel directa (para usos puntuales).
    #[inline]
    pub fn set_pixel(&mut self, x: u32, y: u32) {
        if x >= self.width || y >= self.height { return; }
        let idx = (y as usize) * (self.width as usize) + (x as usize);
        self.pixels[idx] = self.current_color;
    }

    pub fn set_background_color(&mut self, color: Color) {
        self.background_color = color;
    }

    pub fn set_current_color(&mut self, color: Color) {
        self.current_color = color;
    }

    /// Sube el buffer CPU a la textura persistente y la dibuja.
    pub fn swap_buffers(
        &mut self, // <- cambia a &mut self
        window: &mut RaylibHandle,
        raylib_thread: &RaylibThread,
    ) {
        if let Some(tex) = &mut self.texture_gpu {
            let byte_len = self.pixels.len() * std::mem::size_of::<Color>();
            let bytes: &[u8] = unsafe {
                std::slice::from_raw_parts(self.pixels.as_ptr() as *const u8, byte_len)
            };

            // Actualiza TODO el área de la textura (0,0, w, h)
            let rect = Rectangle::new(0.0, 0.0, self.width as f32, self.height as f32);
            tex.update_texture_rec(rect, bytes).expect("update_texture_rec failed");

            let mut d = window.begin_drawing(raylib_thread);
            d.clear_background(Color::BLACK);
            d.draw_texture(tex, 0, 0, Color::WHITE);
        }
    }
}

light.rs:
use raylib::prelude::*;

/// Tipo de luz
#[derive(Clone, Copy, Debug)]
pub enum LightKind {
    Point,      
    Directional,
}

#[derive(Clone, Copy)]
pub struct Light {
    pub kind: LightKind,
    pub position: Vector3,
    pub direction: Vector3,
    pub color: Color,
    pub intensity: f32,
}

impl Light {
    pub fn new(position: Vector3, color: Color, intensity: f32) -> Self {
        Self {
            kind: LightKind::Point,
            position,
            direction: Vector3::new(-1.0, -1.0, -1.0).normalized(),
            color,
            intensity,
        }
    }

    pub fn directional(dir: Vector3, color: Color, intensity: f32) -> Self {
        let d = if dir.length() > 0.0 { dir.normalized() } else { Vector3::new(-1.0,-1.0,-1.0).normalized() };
        Self {
            kind: LightKind::Directional,
            position: Vector3::zero(),
            direction: d,
            color,
            intensity,
        }
    }

    pub fn at(&self, point: Vector3) -> (Vector3, f32) {
        match self.kind {
            LightKind::Point => {
                let to = self.position - point;
                let dist = to.length();
                if dist > 0.0 { (to / dist, dist) } else { (Vector3::new(0.0, -1.0, 0.0), 0.0) }
            }
            LightKind::Directional => {
                (-self.direction, f32::INFINITY)
            }
        }
    }

    pub fn translate(&mut self, delta: Vector3) {
        if matches!(self.kind, LightKind::Point) {
            self.position += delta;
        }
    }

    pub fn yaw_pitch(&mut self, yaw: f32, pitch: f32) {
        if !matches!(self.kind, LightKind::Directional) { return; }
        let mut dir = self.direction;
        let r = dir.length();
        if r == 0.0 { dir = Vector3::new(-1.0,-1.0,-1.0).normalized(); }

        let mut cur_yaw   = dir.z.atan2(dir.x);
        let mut cur_pitch = (dir.y).asin().clamp(-0.999, 0.999);

        cur_yaw += yaw;
        cur_pitch = (cur_pitch + pitch).clamp(-1.3, 1.3);

        let cp = cur_pitch.cos();
        let x = cp * cur_yaw.cos();
        let y = cur_pitch.sin();
        let z = cp * cur_yaw.sin();

        self.direction = Vector3::new(x, y, z).normalized();
    }

    pub fn clone_light_readonly(&self) -> Light {
        Light {
            kind: self.kind,
            position: self.position,
            direction: self.direction,
            color: self.color,
            intensity: self.intensity,
        }
    }
}

main.rs:
use raylib::prelude::*;
use std::f32::consts::PI;
use std::sync::Arc;

mod framebuffer;
mod ray_intersect;
mod sphere;
mod camera;
mod light;
mod material;
mod cube;
mod texture;
mod scene;
mod palette;
mod accel;

use framebuffer::Framebuffer;
use ray_intersect::{Intersect, RayIntersect};
use camera::Camera;
use light::{Light, LightKind};
use material::{Material, vector3_to_color};
use palette::{Palette, CubeTemplate};
use accel::UniformGridAccel;

use crate::texture::Texture;

const ORIGIN_BIAS: f32 = 1e-3;

#[inline]
fn lerp(a: Vector3, b: Vector3, t: f32) -> Vector3 { a * (1.0 - t) + b * t }

#[inline]
fn smooth5(t: f32) -> f32 {
    // smoothstep quintico (suave y sin bandas)
    let t = t.clamp(0.0, 1.0);
    t * t * t * (t * (t * 6.0 - 15.0) + 10.0)
}

fn procedural_sky(dir: Vector3) -> Vector3 {
    let d = dir.normalized();
    // t=0 cerca del horizonte, t=1 en el cénit
    let t = ((d.y) * 0.5 + 0.5).clamp(0.0, 1.0);

    // Paleta "Nocturne Violet" (morado-negro)
    let horizon = Vector3::new(0.08, 0.04, 0.12); // más claro en horizonte
    let mid     = Vector3::new(0.03, 0.015, 0.06);
    let top     = Vector3::new(0.015, 0.010, 0.030); // casi negro con tinte violeta

    // Gradiente en dos tramos con curvas suaves
    let c = if t < 0.6 {
        let k = smooth5(t / 0.6);            // horizonte -> medio
        lerp(horizon, mid, k)
    } else {
        let k = smooth5((t - 0.6) / 0.4);    // medio -> cénit
        lerp(mid, top, k)
    };

    // Leve brillo/magia de horizonte (muy sutil y oscuro, no “blanco”)
    let h = (1.0 - t).clamp(0.0, 1.0);           // 1 cerca del horizonte
    let glow = h.powf(5.0);                      // curva agresiva para que solo afecte abajo
    let glow_col = Vector3::new(0.20, 0.05, 0.15); // magenta oscuro
    let c = c + glow_col * (0.08 * glow);        // intensidad pequeña

    // Pequeña “niebla” atmosférica violeta en bajo ángulo (evita sky totalmente plano)
    let haze = (1.0 - t).powf(2.0) * 0.03;
    let c = c + Vector3::new(haze * 0.6, haze * 0.3, haze);

    // clamp final a [0,1]
    Vector3::new(c.x.clamp(0.0, 1.0), c.y.clamp(0.0, 1.0), c.z.clamp(0.0, 1.0))
}


fn offset_origin(intersect: &Intersect, direction: &Vector3) -> Vector3 {
    let offset = intersect.normal * ORIGIN_BIAS;
    if direction.dot(intersect.normal) < 0.0 { intersect.point - offset } else { intersect.point + offset }
}

fn reflect(incident: &Vector3, normal: &Vector3) -> Vector3 {
    *incident - *normal * 2.0 * incident.dot(*normal)
}

fn refract(incident: &Vector3, normal: &Vector3, refractive_index: f32) -> Option<Vector3> {
    let mut cosi = incident.dot(*normal).max(-1.0).min(1.0);
    let mut etai = 1.0;
    let mut etat = refractive_index;
    let mut n = *normal;

    if cosi > 0.0 {
        std::mem::swap(&mut etai, &mut etat);
        n = -n;
    } else {
        cosi = -cosi;
    }

    let eta = etai / etat;
    let k = 1.0 - eta * eta * (1.0 - cosi * cosi);
    if k < 0.0 { None } else { Some(*incident * eta + n * (eta * cosi - k.sqrt())) }
}

fn cast_shadow(
    intersect: &Intersect,
    light: &Light,
    objects: &[Box<dyn RayIntersect>],
    accel: &UniformGridAccel,
) -> f32 {
    let (light_dir, light_distance) = light.at(intersect.point);
    let shadow_ray_origin = offset_origin(intersect, &light_dir);
    if accel.occluded(&shadow_ray_origin, &light_dir, light_distance, objects) { 1.0 } else { 0.0 }
}

pub fn cast_ray(
    ray_origin: &Vector3,
    ray_direction: &Vector3,
    objects: &[Box<dyn RayIntersect>],
    accel: &UniformGridAccel,
    light: &Light,
    depth: u32,
) -> Vector3 {
    if depth > 3 { return procedural_sky(*ray_direction); }

    let mut intersect = accel.trace(ray_origin, ray_direction, objects);

    if !intersect.is_intersecting {
        return procedural_sky(*ray_direction);
    }

    let (light_dir, _light_distance) = light.at(intersect.point);
    let view_dir  = (*ray_origin - intersect.point).normalized();
    let reflect_dir = reflect(&-light_dir, &intersect.normal).normalized();

    let shadow_intensity = cast_shadow(&intersect, light, objects, accel);
    let light_intensity = light.intensity * (1.0 - shadow_intensity);

    // Half-Lambert (k=0.3) + ambient 0.15
    let diffuse_intensity = ((intersect.normal.dot(light_dir) + 0.3) / 1.3).clamp(0.0, 1.0) * light_intensity;
    let diffuse = intersect.material.diffuse * diffuse_intensity;

    let specular_intensity = view_dir.dot(reflect_dir).max(0.0).powf(intersect.material.specular) * light_intensity;
    let light_color_v3 = Vector3::new(
        light.color.r as f32 / 255.0,
        light.color.g as f32 / 255.0,
        light.color.b as f32 / 255.0
    );
    let specular = light_color_v3 * specular_intensity;

    let albedo = intersect.material.albedo;
    let phong_color = (diffuse + intersect.material.diffuse * 0.15) * albedo[0] + specular * albedo[1];

    // Reflections
    let reflectivity = intersect.material.albedo[2];
    let reflect_color = if reflectivity > 0.0 {
        let reflect_dir = reflect(ray_direction, &intersect.normal).normalized();
        let reflect_origin = offset_origin(&intersect, &reflect_dir);
        cast_ray(&reflect_origin, &reflect_dir, objects, accel, light, depth + 1)
    } else { Vector3::zero() };

    // Refractions
    let transparency = intersect.material.albedo[3];
    let refract_color = if transparency > 0.0 {
        if let Some(refract_dir) = refract(ray_direction, &intersect.normal, intersect.material.refractive_index) {
            let refract_origin = offset_origin(&intersect, &refract_dir);
            cast_ray(&refract_origin, &refract_dir, objects, accel, light, depth + 1)
        } else {
            let reflect_dir = reflect(ray_direction, &intersect.normal).normalized();
            let reflect_origin = offset_origin(&intersect, &reflect_dir);
            cast_ray(&reflect_origin, &reflect_dir, objects, accel, light, depth + 1)
        }
    } else { Vector3::zero() };

    phong_color * (1.0 - reflectivity - transparency) + reflect_color * reflectivity + refract_color * transparency
}

pub fn render(
    framebuffer: &mut Framebuffer,
    objects: &[Box<dyn RayIntersect>],
    accel: &UniformGridAccel,
    camera: &Camera,
    light: &Light,
) {
    let w = framebuffer.width as usize;
    let h = framebuffer.height as usize;

    // Snapshot de la base de cámara para lectura en hilos
    let cam = camera.basis();

    let width_f = framebuffer.width as f32;
    let height_f = framebuffer.height as f32;
    let aspect_ratio = width_f / height_f;
    let fov = PI / 3.0;
    let perspective_scale = (fov * 0.5).tan();

    // ¿Cuántos hilos usar?
    let threads = std::thread::available_parallelism().map(|n| n.get()).unwrap_or(4);
    let rows_per = (h + threads - 1) / threads;

    // Buffer final (de destino) accesible tras juntar resultados
    let pixels = framebuffer.pixels_mut();

    // Scoped threads: pueden tomar prestado &accel y &objects sin 'static
    std::thread::scope(|scope| {
        // Guardamos los join handles y cada bloque local
        let mut joins = Vec::with_capacity(threads);
        // Contenedor para resultados por hilo (y_start, bloque)
        let mut results: Vec<(usize, Vec<Color>)> = Vec::with_capacity(threads);

        for t in 0..threads {
            let y_start = t * rows_per;
            if y_start >= h { break; }
            let y_end = ((t + 1) * rows_per).min(h);

            // Capturas por copia (baratas)
            let light_c = *light; // Light es Copy
            let aspect_ratio_c = aspect_ratio;
            let perspective_scale_c = perspective_scale;
            let width_f_c = width_f;
            let height_f_c = height_f;
            let cam_c = cam;
            let span_w = w;

            // Reservamos un buffer local por hilo
            // Nota: lo crearemos *dentro* del hilo para no mover ownership raro aquí.
            let handle = scope.spawn(move || {
                let span_h = y_end - y_start;
                let mut local = vec![Color::BLACK; span_h * span_w];

                for (row_off, y) in (y_start..y_end).enumerate() {
                    let fy = y as f32;
                    for x in 0..span_w {
                        let fx = x as f32;

                        let mut sx = (2.0 * fx) / width_f_c - 1.0;
                        let mut sy = -(2.0 * fy) / height_f_c + 1.0;

                        sx = sx * aspect_ratio_c * perspective_scale_c;
                        sy = sy * perspective_scale_c;

                        let v_cam = Vector3::new(sx, sy, -1.0).normalized();
                        // base change manual evitando método sobre &self
                        let ray_dir = Vector3::new(
                            v_cam.x * cam_c.right.x + v_cam.y * cam_c.up.x - v_cam.z * cam_c.forward.x,
                            v_cam.x * cam_c.right.y + v_cam.y * cam_c.up.y - v_cam.z * cam_c.forward.y,
                            v_cam.x * cam_c.right.z + v_cam.y * cam_c.up.z - v_cam.z * cam_c.forward.z,
                        );

                        // Usamos &accel y &objects prestados del scope
                        let rgb = cast_ray(&cam_c.eye, &ray_dir, objects, accel, &light_c, 0);
                        local[row_off * span_w + x] = vector3_to_color(rgb);
                    }
                }

                (y_start, local)
            });

            joins.push(handle);
        }

        // Recogemos resultados (join implícito al final del scope, pero queremos orden)
        for j in joins {
            let (y_start, local) = j.join().expect("Hilo de render falló");
            results.push((y_start, local));
        }

        // Copiamos cada bloque local a su sitio en el framebuffer
        for (y_start, local) in results {
            let span_h = local.len() / w;
            for row_off in 0..span_h {
                let dst_start = (y_start + row_off) * w;
                let src_start = row_off * w;
                pixels[dst_start..dst_start + w]
                    .copy_from_slice(&local[src_start..src_start + w]);
            }
        }
    });
}

fn main() {
    let window_width = 1300;
    let window_height = 900;
 
    let (mut window, thread) = raylib::init()
        .size(window_width, window_height)
        .title("Raytracer Example")
        .log_level(TraceLogLevel::LOG_WARNING)
        .build();

    let mut framebuffer = Framebuffer::new(window_width as u32, window_height as u32);

    let mut tmp_img = Image::gen_image_color(window_width, window_height, Color::BLACK);
    let texture = window
        .load_texture_from_image(&thread, &tmp_img)
        .expect("No se pudo crear la textura persistente");
    framebuffer.attach_texture(texture);

    // ======= PALETA =======
    let stone = Material::new(
        Vector3::new(0.55, 0.55, 0.55),
        25.0,
        [0.85, 0.15, 0.0, 0.0],
        0.0,
    );
    let grass_mat = Material::new(
        Vector3::new(1.0, 1.0, 1.0),
        20.0,
        [0.9, 0.1, 0.0, 0.0],
        0.0,
    );
    let crate_mat = Material::new(
        Vector3::new(1.0, 1.0, 1.0),
        30.0,
        [0.8, 0.2, 0.0, 0.0],
        0.0,
    );

    use std::sync::Arc;
    let grass_top   = Arc::new(Texture::from_file("assets/snow_grass/posy.png"));
    let grass_side  = Arc::new(Texture::from_file("assets/snow_grass/posx.png"));
    let grass_bottom= Arc::new(Texture::from_file("assets/snow_grass/negy.png"));
    let dirt_tex    = Arc::new(Texture::from_file("assets/dirt/dirt.png"));

    let log_top     = Arc::new(Texture::from_file("assets/spruce_log/spruce_log_top.png"));
    let log_bottom  = Arc::new(Texture::from_file("assets/spruce_log/spruce_log_top.png"));
    let log_side    = Arc::new(Texture::from_file("assets/spruce_log/spruce_log.png"));

    let planks = Arc::new(Texture::from_file("assets/spruce_planks/spruce_planks.png"));
    
    let glass = Arc::new(Texture::from_file("assets/glass/glass.png"));

    let leaves = Arc::new(Texture::from_file("assets/spruce_leaves/spruce_leaves.png"));

    let ice = Arc::new(Texture::from_file("assets/ice/ice.png"));

    let mut palette = Palette::new();
    //palette.set('G', CubeTemplate::material_only(stone));
    palette.set('X', CubeTemplate::with_top_bottom_sides(grass_mat, grass_top, grass_bottom, grass_side));
    palette.set('D', CubeTemplate::with_same_texture(crate_mat,  dirt_tex));
    palette.set('L', CubeTemplate::with_top_bottom_sides(crate_mat,  log_top, log_bottom, log_side));
    palette.set('P', CubeTemplate::with_same_texture(crate_mat,  planks));
    palette.set('G', CubeTemplate::with_same_texture(crate_mat,  glass));
    palette.set('l', CubeTemplate::with_same_texture(crate_mat,  leaves));
    palette.set('H', CubeTemplate::with_same_texture(crate_mat,  ice));

    // ===== CARGA ESCENA ASCII SIN GAPS =====
    let cube_size = Vector3::new(1.0, 1.0, 1.0);
    let mut params = scene::default_params(cube_size);
    params.gap = Vector3::new(0.0, 0.0, 0.0);
    params.origin = Vector3::new(0.0, 0.0, 0.0);
    params.y0 = -0.5;
    params.y_step = 1.0;

    let default_mat = stone;

    let objects: Vec<Box<dyn RayIntersect>> =
        scene::load_ascii_layers_with_palette("assets/scene", &params, &palette, default_mat)
            .expect("Error leyendo assets/scene");

    // ===== Aceleración por grilla =====
    let accel = UniformGridAccel::build(&objects, cube_size.x.max(0.01));

    // Cámara
    let mut camera = Camera::new(
        Vector3::new(0.0, 1.5, 5.0),
        Vector3::new(0.0, 0.0, 0.0),
        Vector3::new(0.0, 1.0, 0.0),
    );

    // --- NUEVO: configura la cámara orbital de forma centralizada
    camera.set_config(camera::CameraConfig {
        orbit_sensitivity_yaw:   1.0,   // súbele si quieres girar más rápido
        orbit_sensitivity_pitch: 1.0,
        zoom_sensitivity:        0.5,   // controla “lo que avanza” cada paso de zoom
        min_pitch:  -1.45, // -83°
        max_pitch:   1.45, //  83°
        min_distance: 0.5,  // mínimo acercamiento
        max_distance: 2000.0, // MUY grande pero manejable
    });
    let rotation_speed = PI / 100.0; // puedes mantener esta constante para inputs discretos

    // ===== Luz (mut) =====
    // Cambia a Point si prefieres:
    // let mut light = Light::new(Vector3::new(1.0, -1.0, 5.0), Color::WHITE, 1.5);
    let mut light = Light::directional(Vector3::new(-1.0, -1.0, 0.3), Color::new(255,255,255,255), 1.2);

    // Controles
    let dir_rot_speed = PI / 300.0;
    let move_speed = 0.15;

    while !window.window_should_close() {
        // Cámara orbit
        if window.is_key_down(KeyboardKey::KEY_LEFT)  { camera.orbit( rotation_speed, 0.0); }
        if window.is_key_down(KeyboardKey::KEY_RIGHT) { camera.orbit(-rotation_speed, 0.0); }
        if window.is_key_down(KeyboardKey::KEY_DOWN)    { camera.orbit(0.0, -rotation_speed); }
        if window.is_key_down(KeyboardKey::KEY_UP)  { camera.orbit(0.0,  rotation_speed); }

        if window.is_key_down(KeyboardKey::KEY_PAGE_UP)   { camera.zoom(-0.5); }
        if window.is_key_down(KeyboardKey::KEY_PAGE_DOWN) { camera.zoom( 0.5); }

        // Toggle tipo de luz
        if window.is_key_pressed(KeyboardKey::KEY_ONE) { light.kind = LightKind::Point; }
        if window.is_key_pressed(KeyboardKey::KEY_TWO) { light.kind = LightKind::Directional; }

        // Rotar dirección (direccional): J/L (yaw), I/K (pitch)
        if matches!(light.kind, LightKind::Directional) {
            if window.is_key_down(KeyboardKey::KEY_J) { light.yaw_pitch( dir_rot_speed, 0.0); }
            if window.is_key_down(KeyboardKey::KEY_L) { light.yaw_pitch(-dir_rot_speed, 0.0); }
            if window.is_key_down(KeyboardKey::KEY_I) { light.yaw_pitch(0.0,  dir_rot_speed); }
            if window.is_key_down(KeyboardKey::KEY_K) { light.yaw_pitch(0.0, -dir_rot_speed); }
        }

        // Mover posición (puntual): WASD + R/F
        if matches!(light.kind, LightKind::Point) {
            if window.is_key_down(KeyboardKey::KEY_W) { light.translate(Vector3::new( 0.0, 0.0, -move_speed)); }
            if window.is_key_down(KeyboardKey::KEY_S) { light.translate(Vector3::new( 0.0, 0.0,  move_speed)); }
            if window.is_key_down(KeyboardKey::KEY_A) { light.translate(Vector3::new(-move_speed, 0.0, 0.0)); }
            if window.is_key_down(KeyboardKey::KEY_D) { light.translate(Vector3::new( move_speed, 0.0, 0.0)); }
            if window.is_key_down(KeyboardKey::KEY_R) { light.translate(Vector3::new( 0.0,  move_speed, 0.0)); }
            if window.is_key_down(KeyboardKey::KEY_F) { light.translate(Vector3::new( 0.0, -move_speed, 0.0)); }
        }

        framebuffer.clear();
        render(&mut framebuffer, &objects, &accel, &camera, &light);
        framebuffer.swap_buffers(&mut window, &thread);
    }
}

material.rs:
use raylib::prelude::{Color, Vector3};

#[derive(Debug, Clone, Copy)]
pub struct Material {
    pub diffuse: Vector3,
    pub albedo: [f32; 4],
    pub specular: f32,
    pub refractive_index: f32,
}

impl Material {
    pub fn new(diffuse: Vector3, specular: f32, albedo: [f32; 4], refractive_index: f32) -> Self {
        Material {
            diffuse,
            albedo,
            specular,
            refractive_index,
        }
    }

    pub fn black() -> Self {
        Material {
            diffuse: Vector3::zero(),
            albedo: [0.0, 0.0, 0.0, 0.0],
            specular: 0.0,
            refractive_index: 0.0,
        }
    }
}

pub fn vector3_to_color(v: Vector3) -> Color {
    Color::new(
        (v.x * 255.0).min(255.0) as u8,
        (v.y * 255.0).min(255.0) as u8,
        (v.z * 255.0).min(255.0) as u8,
        255,
    )
}

palette.rs:
// palette.rs
use std::collections::HashMap;
use std::sync::Arc;

use crate::material::Material;
use crate::texture::Texture;

/// Orden de caras (importante):
/// [PosX, NegX, PosY, NegY, PosZ, NegZ]
///  - PosY = tapa (arriba), NegY = base.
///  - PosZ = frente, NegZ = fondo.
#[derive(Clone)]
pub struct CubeTemplate {
    pub material: Material,
    pub face_textures: [Option<Arc<Texture>>; 6],
}

impl CubeTemplate {
    /// Solo material (sin texturas)
    pub fn material_only(material: Material) -> Self {
        CubeTemplate {
            material,
            face_textures: [None, None, None, None, None, None],
        }
    }

    /// Misma textura en las 6 caras
    pub fn with_same_texture(material: Material, tex: Arc<Texture>) -> Self {
        CubeTemplate {
            face_textures: [
                Some(tex.clone()), Some(tex.clone()), Some(tex.clone()),
                Some(tex.clone()), Some(tex.clone()), Some(tex),
            ],
            material,
        }
    }

    /// Top / Bottom / Sides (lados iguales), útil para terreno tipo Minecraft
    pub fn with_top_bottom_sides(
        material: Material,
        top: Arc<Texture>,
        bottom: Arc<Texture>,
        side: Arc<Texture>,
    ) -> Self {
        CubeTemplate {
            face_textures: [
                Some(side.clone()),  // PosX
                Some(side.clone()),  // NegX
                Some(top.clone()),   // PosY (tapa)
                Some(bottom.clone()),// NegY (base)
                Some(side.clone()),  // PosZ
                Some(side),          // NegZ
            ],
            material,
        }
    }

    /// 6 caras explícitas (usa `None` para “sin textura” en una cara)
    pub fn with_faces(
        material: Material,
        faces: [Option<Arc<Texture>>; 6],
    ) -> Self {
        CubeTemplate { material, face_textures: faces }
    }
}

pub struct Palette {
    map: HashMap<char, CubeTemplate>,
}

impl Palette {
    pub fn new() -> Self {
        Palette { map: HashMap::new() }
    }
    pub fn set(&mut self, ch: char, tpl: CubeTemplate) {
        self.map.insert(ch, tpl);
    }
    pub fn get(&self, ch: char) -> Option<&CubeTemplate> {
        self.map.get(&ch)
    }
}

ray_intersect.rs:
use raylib::prelude::Vector3;
use crate::material::Material;

#[derive(Debug, Clone, Copy)]
#[allow(dead_code)]
pub struct Intersect {
    pub point: Vector3,
    pub normal: Vector3,
    pub distance: f32,
    pub is_intersecting: bool,
    pub material: Material,
}

impl Intersect {
    pub fn new(point: Vector3, normal: Vector3, distance: f32, material: Material) -> Self {
        Intersect {
            point,
            normal,
            distance,
            is_intersecting: true,
            material,
        }
    }

    pub fn empty() -> Self {
        Intersect {
            point: Vector3::zero(),
            normal: Vector3::zero(),
            distance: 0.0,
            is_intersecting: false,
            material: Material::black(),
        }
    }
}

pub trait RayIntersect: Send + Sync {
    fn ray_intersect(&self, ray_origin: &Vector3, ray_direction: &Vector3) -> Intersect;

    /// AABB en espacio mundo para aceleración (grilla/BVH).
    fn aabb(&self) -> (Vector3, Vector3);
}



scene.rs:
// scene.rs
use std::{fs, io};

use raylib::prelude::Vector3;

use crate::cube::Cube;
use crate::material::Material;
use crate::palette::{CubeTemplate, Palette};
use crate::ray_intersect::RayIntersect;

/// Parámetros para construir la escena a partir de ASCII layers.
pub struct SceneParams {
    pub cube_size: Vector3,
    pub gap: Vector3,
    pub origin: Vector3,
    pub y0: f32,
    pub y_step: f32,
    pub any_non_whitespace_is_solid: bool,
    pub solid_chars: Vec<char>,
}

pub fn load_ascii_layers_with_palette(
    dir: &str,
    params: &SceneParams,
    palette: &Palette,
    default_material: Material,
) -> io::Result<Vec<Box<dyn RayIntersect>>> {
    let mut entries: Vec<_> = fs::read_dir(dir)?
        .filter_map(|e| e.ok())
        .filter(|e| {
            let p = e.path();
            p.is_file() && p.extension().map(|ext| ext == "txt").unwrap_or(false)
        })
        .collect();

    entries.sort_by_key(|e| e.path());

    let mut objects: Vec<Box<dyn RayIntersect>> = Vec::new();

    for (layer_idx, entry) in entries.into_iter().enumerate() {
        let path = entry.path();
        let text = fs::read_to_string(&path)?;

        let mut lines: Vec<String> = text
            .lines()
            .map(|s| s.trim_end_matches(&['\r', '\n'][..]).to_string())
            .collect();

        while matches!(lines.first(), Some(s) if s.trim().is_empty()) { lines.remove(0); }
        while matches!(lines.last(), Some(s) if s.trim().is_empty()) { lines.pop(); }
        if lines.is_empty() { continue; }

        let rows = lines.len();
        let cols = lines.iter().map(|s| s.chars().count()).max().unwrap_or(0);

        // pasos entre centros: SIN GAPS si gap = 0
        let step_x = params.cube_size.x + params.gap.x;
        let step_z = params.cube_size.z + params.gap.z;

        let half_w = (cols as f32 - 1.0) * 0.5;
        let half_h = (rows as f32 - 1.0) * 0.5;

        let y_center = params.y0 + layer_idx as f32 * params.y_step;

        for (r, line) in lines.iter().enumerate() {
            let mut chars = line.chars().collect::<Vec<char>>();
            if chars.len() < cols { chars.resize(cols, ' '); }

            for c in 0..cols {
                let ch = chars[c];

                // sólido si está en paleta o según flags
                let has_tpl = palette.get(ch).is_some();
                let solid = if params.any_non_whitespace_is_solid {
                    !ch.is_whitespace()
                } else {
                    params.solid_chars.contains(&ch) || has_tpl
                };
                if !solid { continue; }

                let x = (c as f32 - half_w) * step_x;
                let z = (r as f32 - half_h) * step_z;
                let center = params.origin + Vector3::new(x, y_center, z);

                let mut cube = Cube::from_center_size(center, params.cube_size, default_material);

                // aplica plantilla si existe
                if let Some(tpl) = palette.get(ch) {
                    cube.material = tpl.material;
                    cube.set_face_textures_from_template(&tpl.face_textures);
                }
                objects.push(Box::new(cube));
            }
        }
    }

    Ok(objects)
}

pub fn default_params(cube_size: Vector3) -> SceneParams {
    SceneParams {
        cube_size,
        gap: Vector3::new(0.0, 0.0, 0.0), // << sin espacios
        origin: Vector3::zero(),
        y0: -cube_size.y * 0.5,
        y_step: cube_size.y,
        any_non_whitespace_is_solid: false, // << usaremos paleta por carácter
        solid_chars: vec!['X'],             // << arranca con 'X'
    }
}

sphere.rs:
use crate::material::Material;
use crate::ray_intersect::{Intersect, RayIntersect};
use raylib::prelude::Vector3;

pub struct Sphere {
    pub center: Vector3,
    pub radius: f32,
    pub material: Material,
}

impl RayIntersect for Sphere {
    fn ray_intersect(&self, ray_origin: &Vector3, ray_direction: &Vector3) -> Intersect {
        let oc = *ray_origin - self.center;

        let a = ray_direction.dot(*ray_direction);
        let b = 2.0 * oc.dot(*ray_direction);
        let c = oc.dot(oc) - self.radius * self.radius;

        let discriminant = b * b - 4.0 * a * c;

        if discriminant > 0.0 {
            let t = (-b - discriminant.sqrt()) / (2.0 * a);
            if t > 0.0 {
                let point = *ray_origin + *ray_direction * t;
                let normal = (point - self.center).normalized();
                let distance = t;

                return Intersect::new(point, normal, distance, self.material);
            }
        }

        Intersect::empty()
    }

    fn aabb(&self) -> (Vector3, Vector3) {
        let r = Vector3::new(self.radius, self.radius, self.radius);
        (self.center - r, self.center + r)
    }
}

texture.rs:
use raylib::prelude::*;

/// Textura CPU-side con muestreo por UV.
/// Guarda el buffer de colores para muestrear sin pedir &mut.
pub struct Texture {
    width: i32,
    height: i32,
    pixels: ImageColors, // Box<[Color]> administrado por raylib-rs
}

impl Texture {
    pub fn from_file(path: &str) -> Self {
        let img = Image::load_image(path).expect("No se pudo cargar la textura");
        let w = img.width();
        let h = img.height();
        let pixels = img.get_image_data(); // row-major, origen top-left
        Texture { width: w, height: h, pixels }
    }

    /// ---- MODO REPEAT (wrap) ----
    /// Devuelve color lineal [0,1] por UV, con wrap repetido.
    /// Convención: v=0 es fila superior (top), v=1 inferior (bottom).
    #[inline]
    pub fn sample_repeat(&self, mut u: f32, mut v: f32) -> Vector3 {
        // Wrap a [0,1)
        u = u.fract();
        if u < 0.0 { u += 1.0; }
        v = v.fract();
        if v < 0.0 { v += 1.0; }

        // Centro de texel: (u*W - 0.5, v*H - 0.5)
        let sx = u * self.width as f32  - 0.5;
        let sy = v * self.height as f32 - 0.5;

        let xi = sx.floor().clamp(0.0, self.width  as f32 - 1.0)  as usize;
        let yi = sy.floor().clamp(0.0, self.height as f32 - 1.0)  as usize;
        let idx = yi * self.width as usize + xi;

        let c = self.pixels[idx];
        Vector3::new(c.r as f32 / 255.0, c.g as f32 / 255.0, c.b as f32 / 255.0)
    }

    /// ---- MODO CLAMP (sin wrap) ----
    /// Clampa los UV a los centros de texel válidos para evitar costuras en 0/1.
    #[inline]
    pub fn sample_clamp(&self, mut u: f32, mut v: f32) -> Vector3 {
        // “Inset” de medio texel en UV-space
        let eps_u = 0.5 / self.width as f32;
        let eps_v = 0.5 / self.height as f32;
        u = u.clamp(eps_u, 1.0 - eps_u);
        v = v.clamp(eps_v, 1.0 - eps_v);

        // Centro de texel
        let sx = u * self.width as f32  - 0.5;
        let sy = v * self.height as f32 - 0.5;

        let xi = sx.floor().clamp(0.0, self.width  as f32 - 1.0)  as usize;
        let yi = sy.floor().clamp(0.0, self.height as f32 - 1.0)  as usize;
        let idx = yi * self.width as usize + xi;

        let c = self.pixels[idx];
        Vector3::new(c.r as f32 / 255.0, c.g as f32 / 255.0, c.b as f32 / 255.0)
    }

    /// Alias para compatibilidad: por defecto, repeat.
    #[inline]
    pub fn sample(&self, u: f32, v: f32) -> Vector3 {
        self.sample_repeat(u, v)
    }
}

